<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茗一的笔记</title>
  
  <subtitle>沉淀</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mingyi.js.org/"/>
  <updated>2017-11-28T06:08:15.825Z</updated>
  <id>http://mingyi.js.org/</id>
  
  <author>
    <name>Mingyi Liang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode84. Largest Rectangle in Histogram</title>
    <link href="http://mingyi.js.org/2017/11/28/LeetCode84-Largest-Rectangle-in-Histogram/"/>
    <id>http://mingyi.js.org/2017/11/28/LeetCode84-Largest-Rectangle-in-Histogram/</id>
    <published>2017-11-28T13:53:54.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt=""></p><p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt=""></p><p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><p>For example,<br>Given heights = <code>[2,1,5,6,2,3]</code>,<br>return 10.</p><p>栈顶元素比新元素小时，入栈，确定左边界，当栈顶元素比新元素大时，出栈，确定右边界，并计算此时的面积，顺带比较最大值。时间复杂度O(n)</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    int largestRectangleArea(<span class="title">vector</span>&lt;<span class="title">int</span>&gt;&amp; <span class="title">heights</span>) &#123;</span></span><br><span class="line"><span class="class">        int n = heights.size(), result = 0, h;</span></span><br><span class="line"><span class="class">        stack&lt;int&gt; s;</span></span><br><span class="line"><span class="class">        for (<span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">n</span>; <span class="title">i</span>++) &#123;</span></span><br><span class="line"><span class="class">            while(!<span class="title">s</span>.<span class="title">empty</span>() &amp;&amp; heights[s.top()] &gt; heights[i]) &#123;</span></span><br><span class="line"><span class="class">                h = heights[s.top()];</span></span><br><span class="line"><span class="class">                s.pop();</span></span><br><span class="line"><span class="class">                result = max(<span class="title">result</span>, (<span class="title">i</span> - 1 - (<span class="title">s</span>.<span class="title">empty</span>()?(-1):s.top())) * h);</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">            s.push(<span class="title">i</span>);</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        while(!<span class="title">s</span>.<span class="title">empty</span>()) &#123;</span></span><br><span class="line"><span class="class">            h = heights[s.top()];</span></span><br><span class="line"><span class="class">            s.pop();</span></span><br><span class="line"><span class="class">            result = max(<span class="title">result</span>, (<span class="title">n</span> - 1 - (<span class="title">s</span>.<span class="title">empty</span>()?(-1):s.top())) * h);</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        return result;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode92. Reverse Linked List II</title>
    <link href="http://mingyi.js.org/2017/11/27/LeetCode92-Reverse-Linked-List-II/"/>
    <id>http://mingyi.js.org/2017/11/27/LeetCode92-Reverse-Linked-List-II/</id>
    <published>2017-11-27T20:42:06.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p><p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, m = 2 and n = 4,</p><p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p><p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p><p>链表的操作，不难，就是比较繁琐，在纸上先画出操作步骤理清思路。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="symbol">class</span> Solution &#123;</span><br><span class="line"><span class="symbol">public</span>:</span><br><span class="line">    ListNode* <span class="keyword">reverseLinklist(ListNode* </span>head) &#123;</span><br><span class="line">        ListNode *<span class="built_in">p1</span> = head, *<span class="built_in">p2</span> = head-&gt;next, *tmp<span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p2</span>) &#123;</span><br><span class="line">            tmp = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span>-&gt;next = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p2</span><span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span> = tmp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = nullptr<span class="comment">;</span></span><br><span class="line">        return <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* <span class="keyword">reverseBetween(ListNode* </span>head, int m, int n) &#123;</span><br><span class="line">        <span class="meta">if</span> (head == nullptr <span class="title">||</span> head-&gt;next == nullptr <span class="title">||</span> m == n)</span><br><span class="line">            return head<span class="comment">;</span></span><br><span class="line">        ListNode *<span class="built_in">p1</span> = head, *dummy = new ListNode(-<span class="number">1</span>), *<span class="built_in">p2</span> = dummy, *<span class="built_in">p3</span>, *<span class="built_in">p4</span>, *<span class="built_in">p5</span><span class="comment">;</span></span><br><span class="line">        dummy-&gt;next = head<span class="comment">;</span></span><br><span class="line">        int i = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p1</span>) &#123;</span><br><span class="line">            <span class="meta">if</span> (i == m &amp;&amp; <span class="built_in">p2</span>) &#123;</span><br><span class="line">                <span class="built_in">p2</span>-&gt;next = nullptr<span class="comment">;</span></span><br><span class="line">                <span class="built_in">p3</span> = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">            &#125; <span class="meta">else</span> <span class="meta">if</span> (i &lt; m) &#123;</span><br><span class="line">                <span class="built_in">p2</span> = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">if</span> (i == n) &#123;</span><br><span class="line">                <span class="built_in">p4</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">                <span class="built_in">p1</span>-&gt;next = nullptr<span class="comment">;</span></span><br><span class="line">                <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            i++<span class="comment">;     </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">p5</span> = <span class="keyword">reverseLinklist(p3);</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">p2</span>-&gt;next = <span class="built_in">p5</span><span class="comment">;</span></span><br><span class="line">        <span class="built_in">p3</span>-&gt;next = <span class="built_in">p4</span><span class="comment">;</span></span><br><span class="line">        return dummy-&gt;next<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reverse a linked list from position m to n. Do it in-place and in one-pass.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode142. Linked List Cycle II</title>
    <link href="http://mingyi.js.org/2017/11/27/LeetCode142-Linked-List-Cycle-II/"/>
    <id>http://mingyi.js.org/2017/11/27/LeetCode142-Linked-List-Cycle-II/</id>
    <published>2017-11-27T18:57:09.000Z</published>
    <updated>2017-11-28T06:08:15.821Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>Note: Do not modify the linked list.</p><p>Follow up:<br>Can you solve it without using extra space?</p><p>笨办法就是把每个节点的地址塞入一个set里，每次set之前先find，第一次find到的那就是环的起始位置，这种方法需要额外的set容器。另一种做法仍然是用两根指针，p1每次走一步，p2每次走两步，当p1与p2相遇时，p1走过a步，p2走过b步。b = 2a; b - a = n <em> k; n 为p2在环内转的圈数，k为环的大小，则a = n </em> k；将p1放回起点，与p2再一起每次走一步，再次遇到的点即为换的起点。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="symbol">class</span> Solution &#123;</span><br><span class="line"><span class="symbol">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *<span class="built_in">p1</span> = head, *<span class="built_in">p2</span> = head, *ret<span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p1</span> &amp;&amp; <span class="built_in">p2</span>) &#123;</span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span> = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">if</span> (<span class="built_in">p2</span> == nullptr <span class="title">||</span> <span class="built_in">p2</span>-&gt;next == nullptr) &#123;</span><br><span class="line">                ret = nullptr<span class="comment">;</span></span><br><span class="line">                return ret<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">p2</span> = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="meta">if</span> (<span class="built_in">p1</span> == <span class="built_in">p2</span>) &#123;</span><br><span class="line">                <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">if</span> (<span class="built_in">p1</span> == head) &#123;</span><br><span class="line">            return <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">p1</span> = head<span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p1</span> &amp;&amp; <span class="built_in">p2</span>) &#123;</span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span> = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">if</span> (<span class="built_in">p1</span> == <span class="built_in">p2</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">                <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;/p&gt;
&lt;p&gt;Note: Do not modify the linked lis
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode138. Copy List with Random Pointer</title>
    <link href="http://mingyi.js.org/2017/11/27/LeetCode138-Copy-List-with-Random-Pointer/"/>
    <id>http://mingyi.js.org/2017/11/27/LeetCode138-Copy-List-with-Random-Pointer/</id>
    <published>2017-11-27T18:21:00.000Z</published>
    <updated>2017-11-28T06:08:15.821Z</updated>
    
    <content type="html"><![CDATA[<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><p>带有一个random指针链表的拷贝。先在每个节点后面复制一个节点，然后再将复制的新节点的random指向新的节点。最后将新链表分离出来</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode *copyRandomList(RandomListNode *head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == nullptr)</span><br><span class="line">            return nullptr;</span><br><span class="line">            </span><br><span class="line">        RandomListNode *p = head, *tmp;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            R<span class="function"><span class="title">andomListNode</span> *n = new RandomListNode(p-&gt;</span>label); </span><br><span class="line">            <span class="function"><span class="title">tmp</span> = p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>next = n;</span><br><span class="line">            <span class="function"><span class="title">n</span>-&gt;</span>next = tmp;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = head;</span><br><span class="line">        <span class="function"><span class="title">while</span> (p &amp;&amp; p-&gt;</span>next) &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">random</span> = p-&gt;</span><span class="function"><span class="title">random</span> == nullptr ? nullptr : p-&gt;</span><span class="function"><span class="title">random</span>-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = head;</span><br><span class="line">        R<span class="function"><span class="title">andomListNode</span> *h = p-&gt;</span>next, *t = h, *tail = p;</span><br><span class="line">        <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">            <span class="function"><span class="title">tail</span>-&gt;</span><span class="function"><span class="title">next</span> = t-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">if</span> (tail-&gt;</span>next == nullptr) &#123;</span><br><span class="line">                <span class="function"><span class="title">t</span>-&gt;</span>next = nullptr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">next</span> = tail-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">tail</span> = tail-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">t</span> = t-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode153. Find Minimum in Rotated Sorted Array</title>
    <link href="http://mingyi.js.org/2017/11/25/LeetCode153-Find-Minimum-in-Rotated-Sorted-Array/"/>
    <id>http://mingyi.js.org/2017/11/25/LeetCode153-Find-Minimum-in-Rotated-Sorted-Array/</id>
    <published>2017-11-25T17:43:45.000Z</published>
    <updated>2017-11-28T06:08:15.821Z</updated>
    
    <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.</p><p>二分的思想</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size() - <span class="number">1</span>, <span class="built_in">mid</span>, ret;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">left</span> == <span class="built_in">right</span>)</span><br><span class="line">            return nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">left</span> &lt; <span class="built_in">right</span>) &#123;</span><br><span class="line">            <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">right</span> - <span class="built_in">left</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = min(nums[<span class="built_in">left</span>], nums[<span class="built_in">right</span>]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">left</span>] &lt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                ret = nums[<span class="built_in">left</span>];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">right</span> - <span class="built_in">left</span> == <span class="number">2</span> &amp;&amp; nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                ret = nums[<span class="built_in">right</span>];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">right</span> = <span class="built_in">mid</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., 0 1 2 4 5 6 7 might become 4
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode724. Find Pivot Index</title>
    <link href="http://mingyi.js.org/2017/11/24/LeetCode724-Find-Pivot-Index/"/>
    <id>http://mingyi.js.org/2017/11/24/LeetCode724-Find-Pivot-Index/</id>
    <published>2017-11-24T11:23:23.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums, write a method that returns the “pivot” index of this array.</p><p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p><p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line">Input: </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: </span><br><span class="line">The <span class="built_in">sum</span> <span class="keyword">of</span> <span class="keyword">the</span> numbers <span class="built_in">to</span> <span class="keyword">the</span> left <span class="keyword">of</span> index <span class="number">3</span> (nums[<span class="number">3</span>] = <span class="number">6</span>) is equal <span class="built_in">to</span> <span class="keyword">the</span> <span class="built_in">sum</span> <span class="keyword">of</span> numbers <span class="built_in">to</span> <span class="keyword">the</span> <span class="literal">right</span> <span class="keyword">of</span> index <span class="number">3.</span></span><br><span class="line">Also, <span class="number">3</span> is <span class="keyword">the</span> <span class="keyword">first</span> index where this occurs.</span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">Input: </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">Output: <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>Explanation:<br>There is no index that satisfies the conditions in the problem statement.<br>Note:</p><ul><li>The length of nums will be in the range [0, 10000].</li><li>Each element nums[i] will be an integer in the range [-1000, 1000].</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int pivotIndex(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int <span class="keyword">ret</span> = -1, <span class="keyword">total</span> = 0, i, len = nums.size(), <span class="keyword">sum</span> = 0;</span><br><span class="line">        <span class="keyword">for</span> (i = 0; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">total</span> += nums[i];</span><br><span class="line">        <span class="keyword">for</span> (i = 0; i &lt; len; <span class="keyword">sum</span>+=nums[i++]) </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">sum</span> *2 == <span class="keyword">total</span> - nums[i]) &#123;</span><br><span class="line">                <span class="keyword">ret</span> = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ret</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array of integers nums, write a method that returns the “pivot” index of this array.&lt;/p&gt;
&lt;p&gt;We define the pivot index as the ind
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode728. Self Dividing Numbers</title>
    <link href="http://mingyi.js.org/2017/11/24/LeetCode728-Self-Dividing-Numbers/"/>
    <id>http://mingyi.js.org/2017/11/24/LeetCode728-Self-Dividing-Numbers/</id>
    <published>2017-11-24T00:12:22.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>A self-dividing number is a number that is divisible by every digit it contains.</p><p>For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.</p><p>Also, a self-dividing number is not allowed to contain the digit zero.</p><p>Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"><span class="section">Input: </span></span><br><span class="line">left = 1, right = 22</span><br><span class="line"><span class="section">Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span></span><br></pre></td></tr></table></figure><p>Note:<br>The boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000.</p><p>依次对范围内的每个数做判断，比较简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSelfDivid</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = num, t2;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (t1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            t2 = t1 % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (t2 == <span class="number">0</span>) &#123;</span><br><span class="line">                ret = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num % t2 != <span class="number">0</span>) &#123;</span><br><span class="line">                ret = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t1 = t1 / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selfDividingNumbers(<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (; left &lt;= right; left ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSelfDivid(left)) &#123;</span><br><span class="line">                ret.push_back(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A self-dividing number is a number that is divisible by every digit it contains.&lt;/p&gt;
&lt;p&gt;For example, 128 is a self-dividing number becaus
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库存储系统漫谈</title>
    <link href="http://mingyi.js.org/2017/10/23/Discussion-on-database-system/"/>
    <id>http://mingyi.js.org/2017/10/23/Discussion-on-database-system/</id>
    <published>2017-10-23T17:32:03.000Z</published>
    <updated>2017-11-28T06:08:15.821Z</updated>
    
    <content type="html"><![CDATA[<h4 id="从大作业说起"><a href="#从大作业说起" class="headerlink" title="从大作业说起"></a>从大作业说起</h4><p>上大学的时候，相信很多学软件工程的同学常会有个大作业要求做一个图书管理系统或人事管理系统，本质上就是设计一个数据库存储系统。我们以图书管理系统为例，假设需要存储的字段有id,name(书名),author(作者)，查询的需求为根据id去获取图书的信息。</p><p>最简单的做法，以id为key，剩下的作为value，在内存中构建一个hashtable，或者R/B tree 比如c++ stl里的map，全内存存储，这是在数据量不大的情况下。内存的随机读写的性能是非常好的，1s中大约能查询1千万次。</p><p>接下来考虑数据量增大的情况，当数据已经在内存中存不下了，那就得靠存磁盘了，通常的考虑是每条记录按顺序存下来，放到一个文件里去，内存中仍然有一个hashtable，以id为key，value为对应数据记录在文件中的offset(偏移量)。这种做法的特点是数据本身是序列化存在磁盘上的，但索引是存内存中的，当要查询的时候，首先在内存中根据id找到对应磁盘文件的offset，再在文件中fseek定位并读出数据</p><p>现在我们来分析下目前这个存储系统的性能是怎样的，通常对一个存储系统来说，性能评价指标是IOPS(每秒做多少次IO)，以SATA磁盘为例，它的寻道时间平均是在10ms，我们每次查询一条数据，需要一次磁盘的寻道操作，也就是说如果忽略掉磁盘的缓存及本身电梯算法带来的优化，1s中只能做100次这样的查询</p><p>再进一步考虑，假设数据量大到索引也不能够全内存了该怎么处理？这里假设id是有序的，就可以考虑用B+ tree来存，B+ tree有三种节点，根节点、非叶子节点、叶子节点，根据B+ tree的特点，非叶子节点的数量一定是比叶子节点的数量少的多，这些节点信息全部是存在磁盘上的，而在实际应用中非叶子节点是会被大量缓存住的，故在分析性能时可以将非叶子节点当做是存储在内存中来分析。</p><p><img src="http://mingyi-1251130916.file.myqcloud.com/blog/B%2BTREE.jpeg" alt=""></p><p>在这种情况下，单个查询是如何进行的呢？从根节点开始, 一层层的找到叶子节点中的数据。非叶子节点的索引信息假设都从内存缓存中读取，相对于磁盘IO来讲，时间可以忽略不计。读取叶子节点的索引值有1次fseek，同时读取数据内容还需要1次fseek。也就是说每次查询要有2次磁盘寻道，qps下降到50；<br>假设有一个范围查询的需求，需要查询id从50 - 100范围的记录。 50个id，要fseek100次。也就是说这个查询要1s才能返回，而且这个时间是完全落在磁盘的随机IO上，很难从硬件或提高并发来做优化，性能是非常糟糕的。在这里很重要的一个思想，是要想办法把所有的随机读随机写都转成顺序读和顺序写。磁盘本身的顺序读写是非常好的，像SATA磁盘每秒可以写50M。那可以考虑数据按照page组织起来，让数据在page之间按id是有序的，这种情况下，我只需要fseek找50所在的偏移量，接下来顺序的读一批，10ms读索引，10ms读50所在的page的数据。读都是以page为单位的。<br>这里如果是全局有序的，而不按page会有什么问题？如果严格有序就会很惨，每次插入新的元素，都会有节点的分裂，会有更多的IO操作。按page的话，page可能没有写满，剩下的一些空间就是用来插这个范围之内的可能写入的其他id。这种方式可以提高一些插入的性能。</p><p>作为一个软件工程的作业，做到这里已经算是非常非常优秀的成果了。对于存储系统而言，接下来还要考虑是怎么访问的，也就是函数API或者叫存储系统的界面。数据库系统提供的访问界面是SQL，事实上我们也可以不通过SQL来访问，比如innodb，能把mysql上面一层去掉，通过HandlerSocket插件提供的API接口，进而不通过SQL去访问它。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>数据库的主要功能是保证ACID。我们前面的访问都只是单个的访问，那么假设我们有两个线程在同时读写，那如何让这两个线程看起来像是独占这个存储系统一样，这就是数据库的隔离性(I)。I是通过锁来保证的，一个操作会锁住的内容比想象的要多得多。A是原子性。数据库保证我们的数据安全，要么是没有做的状态，要么是完成的状态，不应该有中间的状态，即使掉电。C是一致性，系统从一个一致的状态转换到另一个一致的状态，分为强一致性、弱一致性和最终一致性，在分布式存储系统受通信延迟，系统负载等影响，要实现不同的一致性会有不同的挑战，根据具体的业务会做一些取舍；D持久性，数据要持久化存储，同时还要有日志。</p><p>KV的一些NoSQL存储系统，实际上是放宽了ACID的条件约束，来实现更高的性能，比如不支持事务的并发，只支持单条的事务，还有比如一致性，写下去不一定成功，只有当merge的时候才能成功。一般说数据库性能差，主要是因为数据库为了实现ACID、transaction等功能牺牲了性能。</p><h4 id="拿mysql来看数据库系统有哪些模块"><a href="#拿mysql来看数据库系统有哪些模块" class="headerlink" title="拿mysql来看数据库系统有哪些模块"></a>拿mysql来看数据库系统有哪些模块</h4><p><img src="http://mingyi-1251130916.file.myqcloud.com/blog/mysql-engine-overview.png" alt=""></p><p>比较重要的几个模块：</p><ol><li>数据库客户端，通常来说会做成一个lib，应用端可以通过这个lib来与数据库交互</li><li>连接池，验证/线程重用/最大连接数限制</li><li>SQL解析器，SQL parser</li><li>优化器，根据解析后的SQL的一些条件，决定走哪一个执行路径。使用哪个索引得到需要的数据。同一条SQL语句在不同的执行路径下千差万别，数据库最最重要和复杂的就是优化器，像商业数据库相比开源数据库最大的优势就是优化器会做的更专业，也会存在非常多的专利</li><li>缓存，因为磁盘的随机IO惨不忍睹，所以通常要把查询的结果缓存起来<br>对于缓存来讲，这次读完下次不再需要了的，是完全没必要缓存。而像数据库系统的一个特点是现在要读的通常是刚读过不久的，也就是所谓的时效性的一个热点，这种情况下读缓存和写缓存会起到非常大的作用。缓存利用的好的话，所有查询都落到内存中，qps可能好几千上万，如果不幸的话全部落在磁盘上的话，qps也就只有一两百了。<br>MySQL 5.1以后是插件式的一个系统，数据是怎么结构化存储的、索引是怎么组织的、以及加锁等都是通过接口的方式提供出来，方便做二次开发。只要实现<a href="https://github.com/mysql/mysql-server/blob/5.7/sql/handler.h" target="_blank" rel="noopener">handler.h</a>里的这些接口，就可以做一个MySQL的存储引擎，没有想象的那么复杂。MySQL也自带innodb、myISAM等存储引擎，悲剧在于没有一个存储引擎特别好用。</li><li>存储引擎下面是跟文件系统打交道。数据、索引、日志</li></ol><h4 id="数据库本身是如何做结构化存储"><a href="#数据库本身是如何做结构化存储" class="headerlink" title="数据库本身是如何做结构化存储"></a>数据库本身是如何做结构化存储</h4><ol><li><p>单条记录的结构<br>对于一条数据记录，有些字段可以为空，有些有default值，有些是可以变长的。通常来讲会在记录头记录一个总长度，后面是一些pointer，比如有指向后面哪些字段是可以为空并且为空的等等，之后是根据表结构的定义，一个字段一个字段挨着存储。</p></li><li><p>页的结构<br>将每个记录的指针按插入的顺序串起来，作为page里的数据。注意这些数据并不是按key有序的而是按插入顺序。<br>假设在往page里写一半的时候掉电了，重启之后，怎么判断这个page是好的还是坏的？通常的做法是在page的首尾各加2byte放一个cookie，要么为10或者01，好的page首尾的cookie是一致的，在开始写的时候，头部如果是10就改为01，在写完的时候把尾部的10也改为01。就是说如果读上来一个page，头部是10，尾部是01，那这个page的数据就是坏的。<br>那page如果坏掉了，就要从日志里恢复，所以page里一定还要记一个跟日志相关联的信息叫LSN。<br>日志里要存的信息有 UNDO(做之前)/REDO(做之后)，以及这个操作是在哪个page，还有LSN。单机的话可以拿相对于日志文件头的偏移量作为LSN，也可以用时间戳，集群的话就需要一个中央的授时。<br>在重启后，读出最后一个page的LSN，并找到对应的日志，通过之后的日志可以知道丢了多少条更新可以进行重做，或者事务的回滚</p></li><li><p>表和索引的结构<br>索引是用B+ tree的结构，节点里一般存上page id + record id<br>innodb的实现是区分主键索引和辅助索引。对于主键索引数据本身作为索引的leaf page。这样做按主键做范围查询，性能是非常好的。而对于辅助索引里存放的是主键索引所在的节点地址。<br>如果查询是命中的辅助索引，就会先找到这个辅助索引的leaf page再走一遍主键索引。所以innodb命中主键索引和辅助索引即使是单条查询性能也是不一样的。</p></li></ol><h4 id="数据库的四种访问模式，怎么从数据库里找到一条数据"><a href="#数据库的四种访问模式，怎么从数据库里找到一条数据" class="headerlink" title="数据库的四种访问模式，怎么从数据库里找到一条数据"></a>数据库的四种访问模式，怎么从数据库里找到一条数据</h4><ol><li><p>Table Scan<br>在没有where的时候，或者where条件没有命中任何索引，优化器就什么都不能做了，只能全表扫描。对于大表来说，一个SQL全表扫描跑个几天都是常见的。</p></li><li><p>Index Only<br>有个联合索引 id, name。查询为select name from table where id = xx 在这种情况下，只需要读到这个索引，就可以直接返回了，这是最好的一种情况。</p></li><li><p>Index Match<br>最常见到的，通过id命中index，通过index打开数据文件，将数据内容读取出来返回。</p></li><li><p>Index Scan<br>假设有一个id和name的联合索引，查询是select id from table where name &gt;xxx，这个索引是用不了的。这种时候数据库优化器会发现只要Index Scan就能满足查询要求，故不用Table Scan。</p></li></ol><h4 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h4><p>聚集索引是指数据是按照索引排序的，对于Innodb毫无疑问主键索引就是聚集索引。为什么要按照索引对数据排序，这个主要是在范围查询的时候，按照主键顺序查询的时候性能是很好的。</p><h4 id="总结一下使用数据库系统影响性能的关键"><a href="#总结一下使用数据库系统影响性能的关键" class="headerlink" title="总结一下使用数据库系统影响性能的关键"></a>总结一下使用数据库系统影响性能的关键</h4><p>索引的设计，索引设计的好，直接会是Index Only或者Index Match的，设计的不好就得是Table Scan全表扫描了<br>聚集非聚集索引，对于范围查询是至关重要的<br>数据库SQL性能优化思路</p><ol><li>尽量走索引</li><li>避免随机IO，不多解释了</li><li>Innodb的Insert buffer对写性能的优化<br>随机写主键索引可能需要1到2次IO，辅助索引也可能是1到2次IO，这么多次随机IO导致写入性能是非常低下的。在这里假设所有索引不需要保证唯一性，顺序将数据先写入Insert buffer page，在空闲的时候再把Insert buffer里的数据merge写到最终需要的地方，慢慢去做随机IO。这种在写入高峰期的时候能起到明显的性能提升。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;从大作业说起&quot;&gt;&lt;a href=&quot;#从大作业说起&quot; class=&quot;headerlink&quot; title=&quot;从大作业说起&quot;&gt;&lt;/a&gt;从大作业说起&lt;/h4&gt;&lt;p&gt;上大学的时候，相信很多学软件工程的同学常会有个大作业要求做一个图书管理系统或人事管理系统，本质上就是设计一个
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="存储系统" scheme="http://mingyi.js.org/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何追查诡异问题</title>
    <link href="http://mingyi.js.org/2017/09/10/trouble-shooting-md/"/>
    <id>http://mingyi.js.org/2017/09/10/trouble-shooting-md/</id>
    <published>2017-09-10T22:01:07.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里的“问题“，主要指一个软件系统中，由于硬件故障、程序bug或人为失误而导致的系统异常。<br>“诡异问题”指的是不是那么容易追查的问题，有些问题一看就知道原因，这种问题不在本文讨论之内。<br>解决诡异问题一般会有四个步骤：</p><ol><li>分析问题</li><li>复现问题</li><li>定位问题原因</li><li>寻找解决方案</li></ol><h2 id="一、分析问题"><a href="#一、分析问题" class="headerlink" title="一、分析问题"></a>一、分析问题</h2><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><p>一般来说拿到一个问题，先收集与问题相关的信息。</p><ul><li>是否有相关的业务日志、错误日志</li><li>是否有非业务日志（比如php-error, nginx error_log，系统dmsg等）</li><li>进程/线程状态是否正常（如ps、pstree、top、/proc/$pid、lsof）</li><li>网络状态是否正常（如netstat、ifconfig）</li><li>系统内存、磁盘状态是否正常（如free、df、iostat）</li><li>是否有core文件</li><li>查看程序的版本及changeLog（是否是某个版本的已知问题）</li><li>查看上下游模块是否有异常情况</li><li>……</li></ul><h4 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h4><p>从收集到的信息，可以看出一些不寻常的“现象”，接下来是对这些现象做一些初步分析。下面是一些比较常见的现象的分析思路。</p><ul><li>错误日志：这是最常见的一种现象了，看看具体错误信息，看看报错的是哪一行，到代码里面看具体的逻辑，分析报错的原因</li><li>请求失败：server返回了明确的错误（比如http 500， error_no -1等），这种错误一般是有错误码的，查看错误码对应的错误原因。也可以看server日志，有没有相关的错误日志。</li><li>功能异常：请求并没有明显的失败，但从用户看到的功能来看不正常，比如乱码。这种一般是请求到的数据有异常，需要深入业务逻辑，查看系统各环节的数据，看看是从哪个环节开始出现异常，可以用二分法排查。</li><li>响应超时或长耗时：对比下client日志和server日志，看是否server真正长耗时，还是中间的网络延时。如果server真的长耗时，需要查看server各阶段日志，看看哪一阶段耗时长。</li><li>连接失败：可能是server端口异常，可能是网络异常。尝试手动连接端口：nc -vzz $ip $port,分别从client和server所在的机器连接，如果在server所在机器连接不上端口，说明端口不存在。如果server能连接，client不能，可能是中间的网络问题，可以尝试ping一下。也可能是server设置了一些防火墙策略，可以尝试server上面的其它端口看能否连接。</li><li>出core：首先用gdb查看core堆栈，如果是多线程程序，除了出core的那个线程，还可以看看其它线程都在做什么。</li><li>hang死：这种情况进程是存活的，但是不工作了，可以gdb attach上去看看系统堆栈，看看hang在什么堆栈上，同样看看每个线程都在做什么。</li><li>cpu打满：这种情况下进程是存活的而且一直在使用cpu，同样可以gdb attach上去看看在做什么，还可以在gdb里面输入continue让它继续执行，一会再Ctrl+C看看在做什么。</li><li>内存泄漏：这种情况下进程工作正常但是占用的内存一直在增长。先确定是否是持续增长，有些程序随着压力的增大内存占用会增大，这是正常的，如果在压力恒定情况下，内存还一直增长，那很有可能就是内存泄漏了。</li><li>机器无法登录：可尝试ping下，如果ping不通，说明网络不通，或者ip已经不存在。如果能ping通，但是ssh超时，那可能是机器假死，比如cpu打满、内存用满之类的。如果ssh立即返回错误，那有可能是密码错误或者没权限。</li><li>……</li></ul><h4 id="因素分析"><a href="#因素分析" class="headerlink" title="因素分析"></a>因素分析</h4><p>从现象初步分析后，还可以从因素角度分析，看看问题和哪些因素有关。</p><ul><li>时间因素<ul><li>问题发生的时间有没有什么规律，比如每天高峰期容易出现，则可能与压力有关；比如每隔固定时间间隔出现，可能与定时任务有关。</li><li>问题发生的时间点，有没有什么相关事件，比如上线、重启等。</li></ul></li><li>空间因素<ul><li>问题发生的地点（机器）有什么规律，比如固定在某台机器出现，固定在某个网段出现，则可能和这些机器、机房、网段有关。</li><li>比如说固定在某台机器出现，那么可以对比下这台机器和其它机器有什么不同，比如硬件、操作系统版本、环境变量、上面部署的程序、代码、配置有什么不同。</li></ul></li><li>软件因素<ul><li>问题发生所在的软件有什么规律，比如只在某个模块出现，或者只在某个接口出现，或者只在某个参数传某个值的时候出现</li><li>那么可以对比一下这个模块/接口和其它的模块/接口有什么不同，比如是否会走到不同的业务逻辑分支</li><li>这里的软件因素可以是不同层面的，比如用户/客户端输入、配置/数据、业务代码、框架/基础库、语言/Runtime等都可以算软件层面的因素。</li></ul></li></ul><h2 id="二、复现问题"><a href="#二、复现问题" class="headerlink" title="二、复现问题"></a>二、复现问题</h2><p>按问题发生的条件，可以分为</p><ul><li>无法复现：问题只发生过一次或几次，之后再也无法出现</li><li>不稳定复现：按照某个确定的步骤操作，问题有一定概率会出现</li><li>稳定复现：按照某个确定性的步骤操作，问题必然出现<br>从定位问题的难度来看，显然是 无法复现 &gt; 不稳定复现 &gt; 稳定复现。<br>从复现的场景分，又可分为线上复现和线下复现。从定位问题的难度来看，显然是 线上复现 &gt; 线下复现。<br>由于线上是用户的真实流量，不能随意做各种实验，所以给定位问题会带来很大困难，因此我们第一步要想方设法实现线下复现，然后再想办法做到线下稳定复现。</li></ul><h4 id="线下复现"><a href="#线下复现" class="headerlink" title="线下复现"></a>线下复现</h4><p>一般来说线下复现就需要构造和线上尽量一致的条件。</p><ul><li>硬件、网络一致，这点一般比较难做到，因为线下测试机和线上机器总有各种不一样。好在硬件问题一般是比较少见的。</li><li>软件环境一致，包括操作系统、环境变量、程序、配置、数据、依赖服务（这个比较难，可以考虑采用mock方式）。</li><li>输入请求一致，可以用tcpcopy从线上拷贝真实流量，到线下回放</li></ul><h4 id="稳定复现"><a href="#稳定复现" class="headerlink" title="稳定复现"></a>稳定复现</h4><p>如何把不稳定复现变成稳定复现？<br>想办法增加问题发生的概率。<br>一些常规的方法如：</p><ul><li>加大流量压力</li><li>增加请求的并发，包括调大客户端的请求并发数，以及服务端的并发数（进程/线程数）</li><li>减少服务端的并发数，这和上一条并不冲突，这是为了更快地制造请求达到处理瓶颈的条件，有些问题在请求达到瓶颈的时候更容易暴露出来</li><li>构造各种异常请求，如非法类型、超长请求、不存在的id等进行不断尝试</li><li>构造一些服务异常，如配置不存在ip、端口，故意杀死进程等<br>但是上述方法，缺乏针对性，实际操作的时候，需要根据具体问题发生的条件，来分析。比如经过前面的因素分析发现问题只出现在某个模块某个接口上，那么就专门针对这个模块这个接口进行复现，那么复现的概率会大很多。如果没能复现，那么估计是有某个因素我们尚未发现，没有去构造出这个因素。<br>当问题发生的概率够大时，比如在起压力的情况下每1分钟出一次问题，那就可以进行下一步的问题定位了。</li></ul><h4 id="无法复现的情况"><a href="#无法复现的情况" class="headerlink" title="无法复现的情况"></a>无法复现的情况</h4><p>这是最麻烦的情况了，可能是线上一直没有再出现过，也可能是线上还出现但线下一直没能复现。而且，经过前面的现象分析和因素分析也没能得到更多有用的线索。<br>在这种情况下，可以尝试为程序增加更多详细的日志，然后等待线上再次出现，这些日志可以为我们提供进一步的线索。</p><h2 id="三、定位问题原因"><a href="#三、定位问题原因" class="headerlink" title="三、定位问题原因"></a>三、定位问题原因</h2><p>定位问题有多种方法，常见的方法是因素测试和调试。</p><h4 id="因素测试（控制变量法）"><a href="#因素测试（控制变量法）" class="headerlink" title="因素测试（控制变量法）"></a>因素测试（控制变量法）</h4><p>和前面的因素分析类似，因素测试就是人为地构造更多因素不一样的场景，来测试问题是否和某个因素有关。<br>比如说，修改程序版本，看问题是否发生。如果有的版本有问题，有的版本没问题，那就可以确定，是某些版本引入的问题。通过二分法，可以精确定位到是哪个版本引入的问题。<br>又比如说，调整server的线程数，如果线程数为1的时候没问题，线程数大于1的时候有问题，那说明是多线程带来的问题。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试有两种方式，一种是通过打日志，把程序内部的一些信息打印出来。另一种是使用比如gdb这样的工具，设置断点然后单步进去查看各种变量的值。<br>打日志的优点是可以用于非稳定复现的情况（不是每个请求都必然出问题），日志可以一直打，积累足够多的请求到问题复现了，再回头来分析日志。缺点是需要改代码，如果是C模块这种还得重新编译，麻烦。<br>gdb这种工具调试的优点是不用改代码，缺点是一般只能用于稳定复现的情况。<br>工具分析</p><p>有很多工具可以用于分析问题，比如valgrind可用于检测内存非法使用和内存泄漏，gperftool可以用于检测cpu性能瓶颈和内存泄漏，strace可用于追踪系统调用的情况。关于工具的使用可以详见这里。</p><h2 id="四、寻找解决方案"><a href="#四、寻找解决方案" class="headerlink" title="四、寻找解决方案"></a>四、寻找解决方案</h2><p>原因都定位出来了，解决方案就不成问题了：）<br>一般来说，应该解决根本原因（比如某个程序bug，那就修复这个bug）。</p><p>但是有时候，解决根本原因的成本较高（比如要修改第三方开源库），而线上问题又比较紧急，这时可以先考虑从上层去规避。前面通过因素分析、因素测试可以找出影响问题的一些因素，那么可以通过修改因素来规避。（比如发现在某些机器上有问题，其它机器没问题，可以先把有问题的机器摘除）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这里的“问题“，主要指一个软件系统中，由于硬件故障、程序bug或人为失误而导致的系统异常。&lt;br&gt;“诡异问题”指的是不是那么容易追查的问题，
      
    
    </summary>
    
    
      <category term="项目总结" scheme="http://mingyi.js.org/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode28. Implement strStr()</title>
    <link href="http://mingyi.js.org/2017/03/12/LeetCode28-Implement-strStr/"/>
    <id>http://mingyi.js.org/2017/03/12/LeetCode28-Implement-strStr/</id>
    <published>2017-03-12T12:28:40.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>Implement strStr().</p><p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><p>简单的做法双重循环，依次去比较，时间复杂度O(m*n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = haystack.length(), len2 = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (len2 &gt; len1) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span> &amp;&amp; len2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2 + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == len2)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然还有很多其它解法，比如KMP，最优时间复杂度O(n)。翻出算法导论，复习了下KMP，无论理解还是写起来都还是比较费劲的（只见过一位清华学霸徒手写完整过），网上的解读资料也是非常多的，有一篇思路比较清晰易懂的，<a href="http://www.matrix67.com/blog/archives/115" target="_blank" rel="noopener">KMP算法详解</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; failure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetFailureFunction</span><span class="params">(<span class="built_in">string</span>&amp; needle)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        failure.assign(needle.size(), <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; needle.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = failure[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>( (needle[j] != needle[i+<span class="number">1</span>]) &amp;&amp; (i&gt;=<span class="number">0</span>) )&#123;</span><br><span class="line">                i = failure[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(needle[j] == needle[i+<span class="number">1</span>])&#123;</span><br><span class="line">                failure[j] = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span>&amp; haystack, <span class="built_in">string</span>&amp; needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i&lt;haystack.size() &amp;&amp; j&lt;needle.size() )&#123;</span><br><span class="line">            <span class="keyword">if</span>( haystack[i] == needle[j] )&#123;</span><br><span class="line">                i++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( j == <span class="number">0</span> )</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    j = failure[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j &lt; needle.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> i-needle.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        GetFailureFunction(needle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> KMP(haystack,needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Implement strStr().&lt;/p&gt;
&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode24. Swap Nodes in Pairs</title>
    <link href="http://mingyi.js.org/2017/03/10/LeetCode24-Swap-Nodes-in-Pairs/"/>
    <id>http://mingyi.js.org/2017/03/10/LeetCode24-Swap-Nodes-in-Pairs/</id>
    <published>2017-03-10T10:52:43.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p><p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p><p>链表的操作</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (head == nullptr || head-&gt;</span>next == nullptr)</span><br><span class="line">            return head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在头增加一个节点</span></span><br><span class="line">        ListNode pre = ListNode(-<span class="number">1</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        </span><br><span class="line">        L<span class="function"><span class="title">istNode</span> *t1 = &amp;pre, *t2 = t1-&gt;</span><span class="function"><span class="title">next</span>, *t3 = t2-&gt;</span><span class="function"><span class="title">next</span>, *t4 = t3-&gt;</span>next;</span><br><span class="line">        <span class="keyword">while</span> (t3 != nullptr) &#123;</span><br><span class="line">            <span class="function"><span class="title">t1</span>-&gt;</span>next = t3;</span><br><span class="line">            <span class="function"><span class="title">t3</span>-&gt;</span>next = t2;</span><br><span class="line">            <span class="function"><span class="title">t2</span>-&gt;</span>next = t4;</span><br><span class="line">            </span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = t4;</span><br><span class="line">            <span class="function"><span class="title">t3</span> = t2 ? t2-&gt;</span>next : nullptr;</span><br><span class="line">            <span class="function"><span class="title">t4</span> = t3 ? t3-&gt;</span>next : nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/code&gt;, yo
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode70. Climbing Stairs</title>
    <link href="http://mingyi.js.org/2017/03/05/LeetCode70-Climbing-Stairs/"/>
    <id>http://mingyi.js.org/2017/03/05/LeetCode70-Climbing-Stairs/</id>
    <published>2017-03-05T22:20:32.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given n will be a positive integer.</p><h4 id="排列组合问题，可用递归求解；但递归会消耗系统栈空间，在leetcode上提交的时候-在n-44的这个case时，内存会爆。所以还需要对尾递归优化，用循环代替"><a href="#排列组合问题，可用递归求解；但递归会消耗系统栈空间，在leetcode上提交的时候-在n-44的这个case时，内存会爆。所以还需要对尾递归优化，用循环代替" class="headerlink" title="排列组合问题，可用递归求解；但递归会消耗系统栈空间，在leetcode上提交的时候 在n=44的这个case时，内存会爆。所以还需要对尾递归优化，用循环代替~"></a>排列组合问题，可用递归求解；但递归会消耗系统栈空间，在leetcode上提交的时候 在n=44的这个case时，内存会爆。所以还需要对尾递归优化，用循环代替~</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化后"><a href="#优化后" class="headerlink" title="优化后:"></a>优化后:</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="literal">result</span>[n];</span><br><span class="line">        <span class="literal">result</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="literal">result</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            <span class="literal">result</span>[i] = <span class="literal">result</span>[i - <span class="number">1</span>] + <span class="literal">result</span>[i - <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many dist
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode67. Add Binary</title>
    <link href="http://mingyi.js.org/2017/03/02/LeetCode67-Add-Binary/"/>
    <id>http://mingyi.js.org/2017/03/02/LeetCode67-Add-Binary/</id>
    <published>2017-03-02T17:09:22.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>Given two binary strings, return their sum (also a binary string).</p><p>For example,<br>a = <code>&quot;11&quot;</code><br>b = <code>&quot;1&quot;</code><br>Return <code>&quot;100&quot;</code>.</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string addBinary(string a, string b)</span><br><span class="line">    &#123;</span><br><span class="line">        string result = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>, i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || <span class="keyword">sum</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">sum</span> += i &gt;= <span class="number">0</span> ? a[i --] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">sum</span> += j &gt;= <span class="number">0</span> ? b[j --] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            result = <span class="keyword">char</span>(<span class="keyword">sum</span> % <span class="number">2</span> + <span class="string">'0'</span>) + result;</span><br><span class="line">            <span class="keyword">sum</span> /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given two binary strings, return their sum (also a binary string).&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;a = &lt;code&gt;&amp;quot;11&amp;quot;&lt;/code&gt;&lt;br&gt;b = &lt;code&gt;&amp;q
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode39. Combination Sum</title>
    <link href="http://mingyi.js.org/2017/02/25/LeetCode39-Combination-Sum/"/>
    <id>http://mingyi.js.org/2017/02/25/LeetCode39-Combination-Sum/</id>
    <published>2017-02-25T23:48:50.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p><p>The same repeated number may be chosen from C unlimited number of times.</p><p>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set <code>[2, 3, 6, 7]</code> and target 7,<br>A solution set is: </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="跟LeetCode22-Generate-Parentheses类似，递归"><a href="#跟LeetCode22-Generate-Parentheses类似，递归" class="headerlink" title="跟LeetCode22. Generate Parentheses类似，递归"></a>跟<a href="http://mingyi.js.org/2017/02/24/LeetCode22-Generate-Parentheses/">LeetCode22. Generate Parentheses</a>类似，递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        DFS(candidates, target, <span class="number">0</span>, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidates[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            DFS(candidates, target - candidates[i], i, path, result);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode22. Generate Parentheses</title>
    <link href="http://mingyi.js.org/2017/02/24/LeetCode22-Generate-Parentheses/"/>
    <id>http://mingyi.js.org/2017/02/24/LeetCode22-Generate-Parentheses/</id>
    <published>2017-02-24T23:30:18.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="递归来拼字符串；左括号的数量小于n时，可继续添加左括号；右括号的数量小于左括号时，可添加右括号"><a href="#递归来拼字符串；左括号的数量小于n时，可继续添加左括号；右括号的数量小于左括号时，可添加右括号" class="headerlink" title="递归来拼字符串；左括号的数量小于n时，可继续添加左括号；右括号的数量小于左括号时，可添加右括号"></a>递归来拼字符串；左括号的数量小于n时，可继续添加左括号；右括号的数量小于左括号时，可添加右括号</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        helper(<span class="number">0</span>, <span class="number">0</span>, n, <span class="string">""</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == n) &#123; </span><br><span class="line">            result.push_back(s);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">            helper(left + <span class="number">1</span>, right, n, s + <span class="string">'('</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">            helper(left, right + <span class="number">1</span>, n, s + <span class="string">')'</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode20. Valid Parentheses</title>
    <link href="http://mingyi.js.org/2017/02/23/LeetCode20-Valid-Parentheses/"/>
    <id>http://mingyi.js.org/2017/02/23/LeetCode20-Valid-Parentheses/</id>
    <published>2017-02-23T00:49:35.000Z</published>
    <updated>2017-11-28T06:08:15.825Z</updated>
    
    <content type="html"><![CDATA[<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]{}&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not.</p><h4 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; paren;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : s) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>: </span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#123;'</span>: </span><br><span class="line">                <span class="keyword">case</span> <span class="string">'['</span>: paren.push(c); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>: <span class="keyword">if</span> (paren.empty() || paren.top()!=<span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#125;'</span>: <span class="keyword">if</span> (paren.empty() || paren.top()!=<span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span> (paren.empty() || paren.top()!=<span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: ; <span class="comment">// pass</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paren.empty() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a string containing just the characters &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;, &lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;, &lt;code&gt;&amp;#39;{&amp;#39;&lt;/code&gt;, &lt;code&gt;&amp;#39;}&amp;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode19. Remove Nth Node From End of List</title>
    <link href="http://mingyi.js.org/2017/02/22/LeetCode19-Remove-Nth-Node-From-End-of-List/"/>
    <id>http://mingyi.js.org/2017/02/22/LeetCode19-Remove-Nth-Node-From-End-of-List/</id>
    <published>2017-02-22T00:26:42.000Z</published>
    <updated>2017-11-28T06:08:15.821Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, remove the nth node from the end of list and return its head.</p><p>For example,<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Given</span> linked <span class="built_in">list</span>: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, <span class="keyword">and</span> n = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line"><span class="type">After</span> removing the second node from the <span class="keyword">end</span>, the linked <span class="built_in">list</span> becomes <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure></p><h4 id="链表的操作，对头尾进行删除时需要特殊处理，也可采用在头部再增加一个节点，就只需要对删尾节点做特殊处理"><a href="#链表的操作，对头尾进行删除时需要特殊处理，也可采用在头部再增加一个节点，就只需要对删尾节点做特殊处理" class="headerlink" title="链表的操作，对头尾进行删除时需要特殊处理，也可采用在头部再增加一个节点，就只需要对删尾节点做特殊处理"></a>链表的操作，对头尾进行删除时需要特殊处理，也可采用在头部再增加一个节点，就只需要对删尾节点做特殊处理</h4><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     ListNode *<span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(<span class="built_in">int</span> x) : val(x), <span class="keyword">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = getLength(head);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">0</span> || n &lt; <span class="number">1</span>)</span><br><span class="line">            return head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                return <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                return head-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span> - n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            p = p-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* deleted = p-&gt;<span class="keyword">next</span>;</span><br><span class="line">        p-&gt;<span class="keyword">next</span> = (n == <span class="number">1</span> ? <span class="literal">NULL</span> : deleted-&gt;<span class="keyword">next</span>);</span><br><span class="line">        delete deleted;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> getLength(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="built_in">len</span> ++;</span><br><span class="line">            head = head-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="built_in">len</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;&lt;figure class=&quot;highlight ocaml&quot;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode18. 4Sum</title>
    <link href="http://mingyi.js.org/2017/02/22/LeetCode18-4Sum/"/>
    <id>http://mingyi.js.org/2017/02/22/LeetCode18-4Sum/</id>
    <published>2017-02-22T00:00:23.000Z</published>
    <updated>2017-11-28T06:08:15.821Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p>Note: The solution set must not contain duplicate quadruplets.</p><p>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  [-1,  0, 0, 1</span>],</span><br><span class="line">  [<span class="meta">-2, -1, 1, 2</span>],</span><br><span class="line">  [<span class="meta">-2,  0, 0, 2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="3sum的最优解时间复杂度是O-N2-的，4sum如果建立在3sum之上，最优解的时间复杂度是O-N3-，实现代码如下"><a href="#3sum的最优解时间复杂度是O-N2-的，4sum如果建立在3sum之上，最优解的时间复杂度是O-N3-，实现代码如下" class="headerlink" title="3sum的最优解时间复杂度是O(N2)的，4sum如果建立在3sum之上，最优解的时间复杂度是O(N3)，实现代码如下"></a>3sum的最优解时间复杂度是O(N2)的，4sum如果建立在3sum之上，最优解的时间复杂度是O(N3)，实现代码如下</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; <span class="literal">result</span>;</span><br><span class="line">        int s = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (s &lt; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">            return</span> <span class="literal">result</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (accumulate(nums.begin(), nums.<span class="keyword">end</span>(), <span class="number">0</span>) == target) &#123;</span><br><span class="line">                <span class="literal">result</span>.push_back(nums);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="built_in">            return</span> <span class="literal">result</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        </span><br><span class="line">        int <span class="keyword">first</span> = <span class="number">0</span>, <span class="keyword">second</span> = <span class="number">0</span>, <span class="keyword">third</span> = <span class="keyword">second</span> + <span class="number">1</span>, <span class="keyword">fourth</span> = s - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">first</span> = <span class="number">0</span>; <span class="keyword">first</span> &lt; s - <span class="number">3</span>; <span class="keyword">first</span> ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">second</span> = <span class="keyword">first</span> + <span class="number">1</span>; <span class="keyword">second</span> &lt; s - <span class="number">2</span>; <span class="keyword">second</span> ++) &#123;</span><br><span class="line">                <span class="keyword">third</span> = <span class="keyword">second</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">fourth</span> = s - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">third</span> &lt; <span class="keyword">fourth</span>) &#123;</span><br><span class="line">                    int tmpSum = nums[<span class="keyword">first</span>] + nums[<span class="keyword">second</span>] + nums[<span class="keyword">third</span>] + nums[<span class="keyword">fourth</span>];</span><br><span class="line">                    <span class="keyword">if</span> (tmpSum == target) &#123;</span><br><span class="line">                        vector&lt;int&gt; tmp;</span><br><span class="line">                        tmp.push_back(nums[<span class="keyword">first</span>]);</span><br><span class="line">                        tmp.push_back(nums[<span class="keyword">second</span>]);</span><br><span class="line">                        tmp.push_back(nums[<span class="keyword">third</span>]);</span><br><span class="line">                        tmp.push_back(nums[<span class="keyword">fourth</span>]);</span><br><span class="line">                        <span class="literal">result</span>.push_back(tmp);</span><br><span class="line">                        </span><br><span class="line">                        do &#123;</span><br><span class="line">                            <span class="keyword">third</span> ++;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (<span class="keyword">third</span> &lt; <span class="keyword">fourth</span> &amp;&amp; nums[<span class="keyword">third</span>] == nums[<span class="keyword">third</span> - <span class="number">1</span>]);</span><br><span class="line">                        do &#123;</span><br><span class="line">                            <span class="keyword">fourth</span> <span class="comment">--;</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> (<span class="keyword">third</span> &lt; <span class="keyword">fourth</span> &amp;&amp; nums[<span class="keyword">fourth</span>] == nums[<span class="keyword">fourth</span> + <span class="number">1</span>]);</span><br><span class="line">                        </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmpSum &lt; target) &#123;</span><br><span class="line">                        <span class="keyword">third</span> ++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">fourth</span> <span class="comment">--;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">second</span> &lt; s - <span class="number">2</span> &amp;&amp; nums[<span class="keyword">second</span>] == nums[<span class="keyword">second</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">second</span> ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">first</span> &lt; s - <span class="number">3</span> &amp;&amp; nums[<span class="keyword">first</span>] == nums[<span class="keyword">first</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">first</span> ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">        return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in t
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode17. Letter Combinations of a Phone Number</title>
    <link href="http://mingyi.js.org/2017/02/21/LeetCode17-Letter-Combinations-of-a-Phone-Number/"/>
    <id>http://mingyi.js.org/2017/02/21/LeetCode17-Letter-Combinations-of-a-Phone-Number/</id>
    <published>2017-02-21T00:42:28.000Z</published>
    <updated>2017-11-28T06:08:15.821Z</updated>
    
    <content type="html"><![CDATA[<p>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="Alt text"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:Digit</span> <span class="built_in">string</span> <span class="string">"23"</span></span><br><span class="line">Outpu<span class="variable">t:</span> [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure><h4 id="递归，第一个字符和其余字符的结果的组合为最后的结果"><a href="#递归，第一个字符和其余字符的结果的组合为最后的结果" class="headerlink" title="递归，第一个字符和其余字符的结果的组合为最后的结果"></a>递归，第一个字符和其余字符的结果的组合为最后的结果</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">string</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="built_in">int</span> len = digits.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> num = digits[<span class="number">0</span>] - '<span class="number">0</span>';</span><br><span class="line">        <span class="built_in">string</span> val = valueOf(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, j = val.length(); i &lt; j; i++) &#123;</span><br><span class="line">                <span class="literal">result</span>.push_back(<span class="built_in">string</span>(<span class="number">1</span>, val[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;<span class="built_in">string</span>&gt; otherResult = letterCombinations(digits.substr(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, j = val.length(); i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> l = <span class="number">0</span>, m = otherResult.size(); l &lt; m; l++) &#123;</span><br><span class="line">                    <span class="literal">result</span>.push_back(<span class="built_in">string</span>(<span class="number">1</span>, val[i]) + otherResult[l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> valueOf(<span class="built_in">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">string</span> <span class="literal">result</span>;</span><br><span class="line">        switch(num) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="literal">result</span> = <span class="string">"abc"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="literal">result</span> = <span class="string">"def"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: <span class="literal">result</span> = <span class="string">"ghi"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: <span class="literal">result</span> = <span class="string">"jkl"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>: <span class="literal">result</span> = <span class="string">"mno"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>: <span class="literal">result</span> = <span class="string">"pqrs"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>: <span class="literal">result</span> = <span class="string">"tuv"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>: <span class="literal">result</span> = <span class="string">"wxyz"</span>; <span class="keyword">break</span>;</span><br><span class="line">            default: <span class="literal">result</span> = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a digit string, return all possible letter combinations that the number could represent.&lt;/p&gt;
&lt;p&gt;A mapping of digit to letters (just
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode16. 3Sum Closest</title>
    <link href="http://mingyi.js.org/2017/02/20/LeetCode16-3Sum-Closest/"/>
    <id>http://mingyi.js.org/2017/02/20/LeetCode16-3Sum-Closest/</id>
    <published>2017-02-20T23:35:42.000Z</published>
    <updated>2017-11-28T06:08:15.821Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, given<span class="built_in"> array </span>S = &#123;-1 2 1 -4&#125;,<span class="built_in"> and </span>target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><h4 id="除了O-N3-的穷举解法外，还可以通过对数组排序，假设第一个数已经确定，第二个数从左边扫，第三个数从右边扫，然后根据当前和与目标值比较的结果调整第二个或第三个数的位置，时间复杂度O-N2"><a href="#除了O-N3-的穷举解法外，还可以通过对数组排序，假设第一个数已经确定，第二个数从左边扫，第三个数从右边扫，然后根据当前和与目标值比较的结果调整第二个或第三个数的位置，时间复杂度O-N2" class="headerlink" title="除了O(N3)的穷举解法外，还可以通过对数组排序，假设第一个数已经确定，第二个数从左边扫，第三个数从右边扫，然后根据当前和与目标值比较的结果调整第二个或第三个数的位置，时间复杂度O(N2)"></a>除了O(N3)的穷举解法外，还可以通过对数组排序，假设第一个数已经确定，第二个数从左边扫，第三个数从右边扫，然后根据当前和与目标值比较的结果调整第二个或第三个数的位置，时间复杂度O(N2)</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> threeSumClosest(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> accumulate(nums.begin(), nums.<span class="keyword">end</span>(), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        <span class="built_in">int</span> s = nums.<span class="built_in">size</span>(), result = <span class="number">10000000</span>;</span><br><span class="line">        for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> k = s - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="built_in">int</span> tmpSum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(tmpSum - <span class="keyword">target</span>) &lt; <span class="built_in">abs</span>(result - <span class="keyword">target</span>)) &#123;</span><br><span class="line">                    result = tmpSum;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (tmpSum &gt; <span class="keyword">target</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmpSum &lt; <span class="keyword">target</span>) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = <span class="keyword">target</span>;</span><br><span class="line">                    i = s; // break <span class="keyword">out</span> iterator</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the th
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
