<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茗一的笔记</title>
  
  <subtitle>沉淀</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mingyi.js.org/"/>
  <updated>2017-12-04T13:06:04.239Z</updated>
  <id>http://mingyi.js.org/</id>
  
  <author>
    <name>Mingyi Liang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode72. Edit Distance</title>
    <link href="http://mingyi.js.org/2017/12/04/LeetCode72-Edit-Distance/"/>
    <id>http://mingyi.js.org/2017/12/04/LeetCode72-Edit-Distance/</id>
    <published>2017-12-04T21:00:56.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p><p>You have the following 3 operations permitted on a word:</p><p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p><p>最短编辑距离，比较经典的DP求解问题</p><p>状态转移方程<br>dp[i][j] = min(dp[i - 1][j - 1] + same(word1[i - 1], word2[j - 1]), dp[i - 1][j] + 1, dp[i][j - 1] + 1)</p><p>初值<br>dp[0][j] = j<br>dp[i][0] = i</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>), </span><br><span class="line">                                   min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                                  );   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 ste
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode740. Delete and Earn</title>
    <link href="http://mingyi.js.org/2017/12/04/LeetCode740-Delete-and-Earn/"/>
    <id>http://mingyi.js.org/2017/12/04/LeetCode740-Delete-and-Earn/</id>
    <published>2017-12-04T11:20:32.000Z</published>
    <updated>2017-12-04T13:06:04.243Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array nums of integers, you can perform operations on the array.</p><p>In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.</p><p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><p>Example 1:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3, 4, 2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line"><span class="keyword">Delete</span> <span class="number">4</span> <span class="keyword">to</span> earn <span class="number">4</span> points, consequently <span class="number">3</span> <span class="keyword">is</span> also deleted.</span><br><span class="line"><span class="keyword">Then</span>, <span class="keyword">delete</span> <span class="number">2</span> <span class="keyword">to</span> earn <span class="number">2</span> points. <span class="number">6</span> total points <span class="keyword">are</span> earned.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">Output: <span class="number">9</span></span><br><span class="line">Explanation: </span><br><span class="line">Delete <span class="number">3</span> to earn <span class="number">3</span> <span class="built_in">points</span>, deleting both <span class="number">2</span>'s <span class="keyword">and</span> the <span class="number">4</span>.</span><br><span class="line">Then, <span class="built_in">delete</span> <span class="number">3</span> again to earn <span class="number">3</span> <span class="built_in">points</span>, <span class="keyword">and</span> <span class="number">3</span> again to earn <span class="number">3</span> <span class="built_in">points</span>.</span><br><span class="line"><span class="number">9</span> total <span class="built_in">points</span> are earned.</span><br></pre></td></tr></table></figure><p>Note:</p><p>The length of nums is at most 20000.<br>Each element nums[i] is an integer in the range [1, 10000].</p><p>动态规划问题，状态转移方程<br>dp[i] = max(dp[i - 1], dp[i - 2] + a[i])</p><p>初值<br>dp[1] = a[1]<br>dp[2] = max(dp[1], a[2] * 2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10001</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) </span><br><span class="line">            a[i]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">10001</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = max(dp[<span class="number">1</span>], a[<span class="number">2</span>] * <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + a[i] * i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">10000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array nums of integers, you can perform operations on the array.&lt;/p&gt;
&lt;p&gt;In each operation, you pick any nums[i] and delete it to
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode738. Monotone Increasing Digits</title>
    <link href="http://mingyi.js.org/2017/12/03/LeetCode738-Monotone-Increasing-Digits/"/>
    <id>http://mingyi.js.org/2017/12/03/LeetCode738-Monotone-Increasing-Digits/</id>
    <published>2017-12-03T18:52:14.000Z</published>
    <updated>2017-12-04T13:06:04.243Z</updated>
    
    <content type="html"><![CDATA[<p>Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.</p><p>(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x &lt;= y.)</p><p>Example 1:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> N = <span class="number">10</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> N = <span class="number">1234</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> N = <span class="number">332</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">299</span></span><br></pre></td></tr></table></figure><p>Note: N is an integer in the range [0, 10^9].</p><p>比较笨的办法，从N开始，一个一个的判断，直到找到符合要求的数。但其中有很多判断是多余的，可以做一些优化，减少判断的次数。比如当检测332不符合要求，则331、330都是没必要去判断的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkNum</span><span class="params">(<span class="keyword">int</span> &amp;N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = N, t1 = <span class="number">9</span>, t2, offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t) &#123;</span><br><span class="line">            t2 = t % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (t1 &lt; t2) &#123;</span><br><span class="line">                N = t * <span class="built_in">pow</span>(<span class="number">10</span>, offset);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t = t / <span class="number">10</span>;</span><br><span class="line">            offset ++;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = N;</span><br><span class="line">        <span class="keyword">while</span> (ret-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkNum(ret))</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.&lt;/p&gt;
&lt;p&gt;(Recall t
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode739. Daily Temperatures</title>
    <link href="http://mingyi.js.org/2017/12/03/LeetCode739-Daily-Temperatures/"/>
    <id>http://mingyi.js.org/2017/12/03/LeetCode739-Daily-Temperatures/</id>
    <published>2017-12-03T18:46:42.000Z</published>
    <updated>2017-12-04T13:06:04.243Z</updated>
    
    <content type="html"><![CDATA[<p>Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.</p><p>For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].</p><p>Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].</p><p>比较简单，利用栈来做，如果后一个数比前一个数小，则入栈，否则出栈。入栈的同时顺带计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret(len);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; temperatures[i] &gt; temperatures[s.top()]) &#123;</span><br><span class="line">                tmp = ret[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!s.empty()) </span><br><span class="line">                    ret[s.top()] += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            s.push(i);</span><br><span class="line">            ret[s.top()] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            ret[s.top()] = <span class="number">0</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode64. Minimum Path Sum</title>
    <link href="http://mingyi.js.org/2017/12/02/LeetCode64-Minimum-Path-Sum/"/>
    <id>http://mingyi.js.org/2017/12/02/LeetCode64-Minimum-Path-Sum/</id>
    <published>2017-12-02T18:55:20.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p><p>Note: You can only move either down or right at any point in time.</p><p>Example 1:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.</p><p>动态规划问题，先确定状态转移方程，dp[i][j]表示到下标为i,j的位置时的最优解</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">j</span>] = min(dp[<span class="string">i</span>][<span class="symbol">j - 1</span>], dp[<span class="string">i - 1</span>][<span class="symbol">j</span>]) + grid[<span class="string">i</span>][<span class="symbol">j</span>]</span><br></pre></td></tr></table></figure><p>初值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">0</span>][<span class="symbol">0</span>] = grid[<span class="string">0</span>][<span class="symbol">0</span>]</span><br><span class="line">dp[<span class="string">0</span>][<span class="symbol">j &gt; 0</span>] = dp[<span class="string">0</span>][<span class="symbol">j - 1</span>] + grid[<span class="string">i</span>][<span class="symbol">j</span>] // 第一行只能横着走</span><br><span class="line">dp[<span class="string">i &gt; 0</span>][<span class="symbol">0</span>] = dp[<span class="string">i - 1</span>][<span class="symbol">0</span>] + grid[<span class="string">i</span>][<span class="symbol">j</span>] // 最左列只能竖着走</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)，可以通过滚动数组优化把空间复杂度降维到O(n)</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">int</span> minPathSum(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="keyword">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="keyword">grid</span>.<span class="keyword">size</span>(), n = <span class="keyword">grid</span>[<span class="number">0</span>].<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">grid</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="keyword">grid</span>[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="keyword">grid</span>[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="keyword">grid</span>[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers alo
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode108. Convert Sorted Array to Binary Search Tree</title>
    <link href="http://mingyi.js.org/2017/12/02/LeetCode108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
    <id>http://mingyi.js.org/2017/12/02/LeetCode108-Convert-Sorted-Array-to-Binary-Search-Tree/</id>
    <published>2017-12-02T17:25:09.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted array: [<span class="string">-10</span>,<span class="string">-3</span>,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,<span class="string">-3</span>,9,<span class="string">-10</span>,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   <span class="string">-3</span>   9</span><br><span class="line">   /   /</span><br><span class="line"> <span class="string">-10</span>  5</span><br></pre></td></tr></table></figure><p>数组转BST，比链表要简单</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">typedef vector&lt;<span class="built_in">int</span>&gt;::iterator vec_iter;</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* &amp;root, vec_iter first, vec_iter last) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = last - first;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">0</span>)</span><br><span class="line">            return ;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">len</span> - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(*(first + <span class="built_in">mid</span>));</span><br><span class="line">        </span><br><span class="line">        TreeNode *myleft = nullptr, *myright = nullptr;</span><br><span class="line">        helper(myleft, first, first + <span class="built_in">mid</span>);</span><br><span class="line">        helper(myright, first + <span class="built_in">mid</span> + <span class="number">1</span>, last);</span><br><span class="line">        root-&gt;<span class="built_in">left</span> = myleft;</span><br><span class="line">        root-&gt;<span class="built_in">right</span> = myright;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        TreeNode* root = nullptr;</span><br><span class="line">        helper(root, nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;p&gt;For this problem, a height-balan
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode109. Convert Sorted List to Binary Search Tree</title>
    <link href="http://mingyi.js.org/2017/12/01/LeetCode109-Convert-Sorted-List-to-Binary-Search-Tree/"/>
    <id>http://mingyi.js.org/2017/12/01/LeetCode109-Convert-Sorted-List-to-Binary-Search-Tree/</id>
    <published>2017-12-01T18:14:54.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted linked list: [<span class="string">-10</span>,<span class="string">-3</span>,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,<span class="string">-3</span>,9,<span class="string">-10</span>,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   <span class="string">-3</span>   9</span><br><span class="line">   /   /</span><br><span class="line"> <span class="string">-10</span>  5</span><br></pre></td></tr></table></figure><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     ListNode *<span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(<span class="built_in">int</span> x) : val(x), <span class="keyword">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> getLen(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            head = head-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="built_in">len</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="built_in">len</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(ListNode* head, <span class="built_in">int</span> <span class="built_in">len</span>, TreeNode* &amp;root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            root = nullptr;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* <span class="built_in">now</span> = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = (<span class="built_in">len</span> - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">now</span> = <span class="built_in">now</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(<span class="built_in">now</span>-&gt;val);</span><br><span class="line">        TreeNode *<span class="built_in">left</span>, *<span class="built_in">right</span>;</span><br><span class="line">        helper(head, (<span class="built_in">len</span> - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, <span class="built_in">left</span>);</span><br><span class="line">        helper(<span class="built_in">now</span>-&gt;<span class="keyword">next</span>, <span class="built_in">len</span> &gt;&gt; <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">        root-&gt;<span class="built_in">left</span> = <span class="built_in">left</span>;</span><br><span class="line">        root-&gt;<span class="built_in">right</span> = <span class="built_in">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        TreeNode* root;</span><br><span class="line">        helper(head, getLen(head), root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;p&gt;For this problem, a 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode114. Flatten Binary Tree to Linked List</title>
    <link href="http://mingyi.js.org/2017/12/01/LeetCode114-Flatten-Binary-Tree-to-Linked-List/"/>
    <id>http://mingyi.js.org/2017/12/01/LeetCode114-Flatten-Binary-Tree-to-Linked-List/</id>
    <published>2017-12-01T16:16:51.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example,<br>Given</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><p>The flattened tree should look like:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure><p>二叉树转链表</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* &amp;root, TreeNode* &amp;last) &#123;</span><br><span class="line">        last = root;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        TreeNode *mylast, *temp = root-&gt;<span class="built_in">right</span>;</span><br><span class="line">        helper(root-&gt;<span class="built_in">left</span>, mylast);</span><br><span class="line">        <span class="keyword">if</span> (mylast) &#123;</span><br><span class="line">            last = mylast;</span><br><span class="line">            last-&gt;<span class="built_in">right</span> = root-&gt;<span class="built_in">right</span>;</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = root-&gt;<span class="built_in">left</span>;</span><br><span class="line">            root-&gt;<span class="built_in">left</span> = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(root-&gt;<span class="built_in">right</span>, mylast);</span><br><span class="line">        <span class="keyword">if</span> (mylast)</span><br><span class="line">            last = mylast;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *last;</span><br><span class="line">        helper(root, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a binary tree, flatten it to a linked list in-place.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given&lt;/p&gt;
&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode98. Validate Binary Search Tree</title>
    <link href="http://mingyi.js.org/2017/11/30/LeetCode98-Validate-Binary-Search-Tree/"/>
    <id>http://mingyi.js.org/2017/11/30/LeetCode98-Validate-Binary-Search-Tree/</id>
    <published>2017-11-30T18:17:26.000Z</published>
    <updated>2017-12-04T13:06:04.243Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Binary tree <code>[2,1,3]</code>, return true.<br>Example 2:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Binary tree <code>[1,2,3]</code>, return false.</p><p>将BST的中序遍历的结果存起来然后判断是否有序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode* root, <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        travel(root-&gt;left, s);</span><br><span class="line">        s.push(root-&gt;val);</span><br><span class="line">        travel(root-&gt;right, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        travel(root, s);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.top() &gt;= last)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            last = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a binary tree, determine if it is a valid binary search tree (BST).&lt;/p&gt;
&lt;p&gt;Assume a BST is defined as follows:&lt;/p&gt;
&lt;p&gt;The left subt
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode111. Minimum Depth of Binary Tree</title>
    <link href="http://mingyi.js.org/2017/11/30/LeetCode111-Minimum-Depth-of-Binary-Tree/"/>
    <id>http://mingyi.js.org/2017/11/30/LeetCode111-Minimum-Depth-of-Binary-Tree/</id>
    <published>2017-11-30T16:31:48.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        int ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;<span class="built_in">left</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;<span class="built_in">right</span>) &#123;</span><br><span class="line">                ret = min(minDepth(root-&gt;<span class="built_in">left</span>), minDepth(root-&gt;<span class="built_in">right</span>)) + <span class="number">1</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret = minDepth(root-&gt;<span class="built_in">left</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;<span class="built_in">right</span>) &#123;</span><br><span class="line">            ret = minDepth(root-&gt;<span class="built_in">right</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a binary tree, find its minimum depth.&lt;/p&gt;
&lt;p&gt;The minimum depth is the number of nodes along the shortest path from the root node d
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode106. Construct Binary Tree from Inorder and Postorder Traversal</title>
    <link href="http://mingyi.js.org/2017/11/29/LeetCode106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/"/>
    <id>http://mingyi.js.org/2017/11/29/LeetCode106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</id>
    <published>2017-11-29T17:33:26.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>已知树的中序和后序遍历，构建这棵树，跟105思路一样，比较简单</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* helper(vector&lt;<span class="built_in">int</span>&gt;&amp; inorder, vector&lt;<span class="built_in">int</span>&gt;&amp; postorder, <span class="built_in">int</span> inpos, <span class="built_in">int</span> postpos, <span class="built_in">int</span> <span class="built_in">len</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">0</span>)</span><br><span class="line">            return nullptr;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(postorder[postpos + <span class="built_in">len</span> <span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; inorder[i + inpos] != postorder[postpos + <span class="built_in">len</span> <span class="number">-1</span>]; i++) ;</span><br><span class="line">        root-&gt;<span class="built_in">left</span> = helper(inorder, postorder, inpos, postpos, i);</span><br><span class="line">        root-&gt;<span class="built_in">right</span> = helper(inorder, postorder, inpos + i + <span class="number">1</span>, postpos + i, <span class="built_in">len</span> - i - <span class="number">1</span>);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;<span class="built_in">int</span>&gt;&amp; inorder, vector&lt;<span class="built_in">int</span>&gt;&amp; postorder) &#123;</span><br><span class="line">        return helper(inorder, postorder, <span class="number">0</span>, <span class="number">0</span>, postorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given inorder and postorder traversal of a tree, construct the binary tree.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that duplicates do not exist i
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link href="http://mingyi.js.org/2017/11/29/LeetCode105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
    <id>http://mingyi.js.org/2017/11/29/LeetCode105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</id>
    <published>2017-11-29T17:15:20.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>已知树的先序和中序遍历，构建这棵树。比较简单</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    TreeNode* helper(vector&lt;<span class="built_in">int</span>&gt;&amp; preorder, vector&lt;<span class="built_in">int</span>&gt;&amp; inorder, <span class="built_in">int</span> prepos, <span class="built_in">int</span> inpos, <span class="built_in">int</span> <span class="built_in">len</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">0</span>)</span><br><span class="line">            return nullptr;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[prepos]);</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; inorder[i + inpos] != preorder[prepos]; i++) ;</span><br><span class="line">        root-&gt;<span class="built_in">left</span> = helper(preorder, inorder, prepos + <span class="number">1</span>, inpos, i);</span><br><span class="line">        root-&gt;<span class="built_in">right</span> = helper(preorder, inorder, prepos + i + <span class="number">1</span>, inpos + i + <span class="number">1</span>, <span class="built_in">len</span> - i - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* buildTree(vector&lt;<span class="built_in">int</span>&gt;&amp; preorder, vector&lt;<span class="built_in">int</span>&gt;&amp; inorder) &#123;</span><br><span class="line">        return helper(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, inorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given preorder and inorder traversal of a tree, construct the binary tree.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that duplicates do not exist in
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode84. Largest Rectangle in Histogram</title>
    <link href="http://mingyi.js.org/2017/11/28/LeetCode84-Largest-Rectangle-in-Histogram/"/>
    <id>http://mingyi.js.org/2017/11/28/LeetCode84-Largest-Rectangle-in-Histogram/</id>
    <published>2017-11-28T13:53:54.000Z</published>
    <updated>2017-12-04T13:06:04.243Z</updated>
    
    <content type="html"><![CDATA[<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt=""></p><p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt=""></p><p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><p>For example,<br>Given heights = <code>[2,1,5,6,2,3]</code>,<br>return 10.</p><p>栈顶元素比新元素小时，入栈，确定左边界，当栈顶元素比新元素大时，出栈，确定右边界，并计算此时的面积，顺带比较最大值。时间复杂度O(n)</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    int largestRectangleArea(<span class="title">vector</span>&lt;<span class="title">int</span>&gt;&amp; <span class="title">heights</span>) &#123;</span></span><br><span class="line"><span class="class">        int n = heights.size(), result = 0, h;</span></span><br><span class="line"><span class="class">        stack&lt;int&gt; s;</span></span><br><span class="line"><span class="class">        for (<span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">n</span>; <span class="title">i</span>++) &#123;</span></span><br><span class="line"><span class="class">            while(!<span class="title">s</span>.<span class="title">empty</span>() &amp;&amp; heights[s.top()] &gt; heights[i]) &#123;</span></span><br><span class="line"><span class="class">                h = heights[s.top()];</span></span><br><span class="line"><span class="class">                s.pop();</span></span><br><span class="line"><span class="class">                result = max(<span class="title">result</span>, (<span class="title">i</span> - 1 - (<span class="title">s</span>.<span class="title">empty</span>()?(-1):s.top())) * h);</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">            s.push(<span class="title">i</span>);</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        while(!<span class="title">s</span>.<span class="title">empty</span>()) &#123;</span></span><br><span class="line"><span class="class">            h = heights[s.top()];</span></span><br><span class="line"><span class="class">            s.pop();</span></span><br><span class="line"><span class="class">            result = max(<span class="title">result</span>, (<span class="title">n</span> - 1 - (<span class="title">s</span>.<span class="title">empty</span>()?(-1):s.top())) * h);</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        return result;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode92. Reverse Linked List II</title>
    <link href="http://mingyi.js.org/2017/11/27/LeetCode92-Reverse-Linked-List-II/"/>
    <id>http://mingyi.js.org/2017/11/27/LeetCode92-Reverse-Linked-List-II/</id>
    <published>2017-11-27T20:42:06.000Z</published>
    <updated>2017-12-04T13:06:04.243Z</updated>
    
    <content type="html"><![CDATA[<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p><p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, m = 2 and n = 4,</p><p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p><p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p><p>链表的操作，不难，就是比较繁琐，在纸上先画出操作步骤理清思路。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="symbol">class</span> Solution &#123;</span><br><span class="line"><span class="symbol">public</span>:</span><br><span class="line">    ListNode* <span class="keyword">reverseLinklist(ListNode* </span>head) &#123;</span><br><span class="line">        ListNode *<span class="built_in">p1</span> = head, *<span class="built_in">p2</span> = head-&gt;next, *tmp<span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p2</span>) &#123;</span><br><span class="line">            tmp = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span>-&gt;next = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p2</span><span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span> = tmp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = nullptr<span class="comment">;</span></span><br><span class="line">        return <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* <span class="keyword">reverseBetween(ListNode* </span>head, int m, int n) &#123;</span><br><span class="line">        <span class="meta">if</span> (head == nullptr <span class="title">||</span> head-&gt;next == nullptr <span class="title">||</span> m == n)</span><br><span class="line">            return head<span class="comment">;</span></span><br><span class="line">        ListNode *<span class="built_in">p1</span> = head, *dummy = new ListNode(-<span class="number">1</span>), *<span class="built_in">p2</span> = dummy, *<span class="built_in">p3</span>, *<span class="built_in">p4</span>, *<span class="built_in">p5</span><span class="comment">;</span></span><br><span class="line">        dummy-&gt;next = head<span class="comment">;</span></span><br><span class="line">        int i = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p1</span>) &#123;</span><br><span class="line">            <span class="meta">if</span> (i == m &amp;&amp; <span class="built_in">p2</span>) &#123;</span><br><span class="line">                <span class="built_in">p2</span>-&gt;next = nullptr<span class="comment">;</span></span><br><span class="line">                <span class="built_in">p3</span> = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">            &#125; <span class="meta">else</span> <span class="meta">if</span> (i &lt; m) &#123;</span><br><span class="line">                <span class="built_in">p2</span> = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">if</span> (i == n) &#123;</span><br><span class="line">                <span class="built_in">p4</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">                <span class="built_in">p1</span>-&gt;next = nullptr<span class="comment">;</span></span><br><span class="line">                <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            i++<span class="comment">;     </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">p5</span> = <span class="keyword">reverseLinklist(p3);</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">p2</span>-&gt;next = <span class="built_in">p5</span><span class="comment">;</span></span><br><span class="line">        <span class="built_in">p3</span>-&gt;next = <span class="built_in">p4</span><span class="comment">;</span></span><br><span class="line">        return dummy-&gt;next<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reverse a linked list from position m to n. Do it in-place and in one-pass.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode142. Linked List Cycle II</title>
    <link href="http://mingyi.js.org/2017/11/27/LeetCode142-Linked-List-Cycle-II/"/>
    <id>http://mingyi.js.org/2017/11/27/LeetCode142-Linked-List-Cycle-II/</id>
    <published>2017-11-27T18:57:09.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>Note: Do not modify the linked list.</p><p>Follow up:<br>Can you solve it without using extra space?</p><p>笨办法就是把每个节点的地址塞入一个set里，每次set之前先find，第一次find到的那就是环的起始位置，这种方法需要额外的set容器。另一种做法仍然是用两根指针，p1每次走一步，p2每次走两步，当p1与p2相遇时，p1走过a步，p2走过b步。b = 2a; b - a = n <em> k; n 为p2在环内转的圈数，k为环的大小，则a = n </em> k；将p1放回起点，与p2再一起每次走一步，再次遇到的点即为换的起点。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="symbol">class</span> Solution &#123;</span><br><span class="line"><span class="symbol">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *<span class="built_in">p1</span> = head, *<span class="built_in">p2</span> = head, *ret<span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p1</span> &amp;&amp; <span class="built_in">p2</span>) &#123;</span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span> = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">if</span> (<span class="built_in">p2</span> == nullptr <span class="title">||</span> <span class="built_in">p2</span>-&gt;next == nullptr) &#123;</span><br><span class="line">                ret = nullptr<span class="comment">;</span></span><br><span class="line">                return ret<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">p2</span> = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="meta">if</span> (<span class="built_in">p1</span> == <span class="built_in">p2</span>) &#123;</span><br><span class="line">                <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">if</span> (<span class="built_in">p1</span> == head) &#123;</span><br><span class="line">            return <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">p1</span> = head<span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p1</span> &amp;&amp; <span class="built_in">p2</span>) &#123;</span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span> = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">if</span> (<span class="built_in">p1</span> == <span class="built_in">p2</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">                <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;/p&gt;
&lt;p&gt;Note: Do not modify the linked lis
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode138. Copy List with Random Pointer</title>
    <link href="http://mingyi.js.org/2017/11/27/LeetCode138-Copy-List-with-Random-Pointer/"/>
    <id>http://mingyi.js.org/2017/11/27/LeetCode138-Copy-List-with-Random-Pointer/</id>
    <published>2017-11-27T18:21:00.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><p>带有一个random指针链表的拷贝。先在每个节点后面复制一个节点，然后再将复制的新节点的random指向新的节点。最后将新链表分离出来</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode *copyRandomList(RandomListNode *head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == nullptr)</span><br><span class="line">            return nullptr;</span><br><span class="line">            </span><br><span class="line">        RandomListNode *p = head, *tmp;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            R<span class="function"><span class="title">andomListNode</span> *n = new RandomListNode(p-&gt;</span>label); </span><br><span class="line">            <span class="function"><span class="title">tmp</span> = p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>next = n;</span><br><span class="line">            <span class="function"><span class="title">n</span>-&gt;</span>next = tmp;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = head;</span><br><span class="line">        <span class="function"><span class="title">while</span> (p &amp;&amp; p-&gt;</span>next) &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">random</span> = p-&gt;</span><span class="function"><span class="title">random</span> == nullptr ? nullptr : p-&gt;</span><span class="function"><span class="title">random</span>-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = head;</span><br><span class="line">        R<span class="function"><span class="title">andomListNode</span> *h = p-&gt;</span>next, *t = h, *tail = p;</span><br><span class="line">        <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">            <span class="function"><span class="title">tail</span>-&gt;</span><span class="function"><span class="title">next</span> = t-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">if</span> (tail-&gt;</span>next == nullptr) &#123;</span><br><span class="line">                <span class="function"><span class="title">t</span>-&gt;</span>next = nullptr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">next</span> = tail-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">tail</span> = tail-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">t</span> = t-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode153. Find Minimum in Rotated Sorted Array</title>
    <link href="http://mingyi.js.org/2017/11/25/LeetCode153-Find-Minimum-in-Rotated-Sorted-Array/"/>
    <id>http://mingyi.js.org/2017/11/25/LeetCode153-Find-Minimum-in-Rotated-Sorted-Array/</id>
    <published>2017-11-25T17:43:45.000Z</published>
    <updated>2017-12-04T13:06:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.</p><p>二分的思想</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size() - <span class="number">1</span>, <span class="built_in">mid</span>, ret;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">left</span> == <span class="built_in">right</span>)</span><br><span class="line">            return nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">left</span> &lt; <span class="built_in">right</span>) &#123;</span><br><span class="line">            <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">right</span> - <span class="built_in">left</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = min(nums[<span class="built_in">left</span>], nums[<span class="built_in">right</span>]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">left</span>] &lt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                ret = nums[<span class="built_in">left</span>];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">right</span> - <span class="built_in">left</span> == <span class="number">2</span> &amp;&amp; nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                ret = nums[<span class="built_in">right</span>];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">right</span> = <span class="built_in">mid</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., 0 1 2 4 5 6 7 might become 4
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode724. Find Pivot Index</title>
    <link href="http://mingyi.js.org/2017/11/24/LeetCode724-Find-Pivot-Index/"/>
    <id>http://mingyi.js.org/2017/11/24/LeetCode724-Find-Pivot-Index/</id>
    <published>2017-11-24T11:23:23.000Z</published>
    <updated>2017-12-04T13:06:04.243Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums, write a method that returns the “pivot” index of this array.</p><p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p><p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line">Input: </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: </span><br><span class="line">The <span class="built_in">sum</span> <span class="keyword">of</span> <span class="keyword">the</span> numbers <span class="built_in">to</span> <span class="keyword">the</span> left <span class="keyword">of</span> index <span class="number">3</span> (nums[<span class="number">3</span>] = <span class="number">6</span>) is equal <span class="built_in">to</span> <span class="keyword">the</span> <span class="built_in">sum</span> <span class="keyword">of</span> numbers <span class="built_in">to</span> <span class="keyword">the</span> <span class="literal">right</span> <span class="keyword">of</span> index <span class="number">3.</span></span><br><span class="line">Also, <span class="number">3</span> is <span class="keyword">the</span> <span class="keyword">first</span> index where this occurs.</span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">Input: </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">Output: <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>Explanation:<br>There is no index that satisfies the conditions in the problem statement.<br>Note:</p><ul><li>The length of nums will be in the range [0, 10000].</li><li>Each element nums[i] will be an integer in the range [-1000, 1000].</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int pivotIndex(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int <span class="keyword">ret</span> = -1, <span class="keyword">total</span> = 0, i, len = nums.size(), <span class="keyword">sum</span> = 0;</span><br><span class="line">        <span class="keyword">for</span> (i = 0; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">total</span> += nums[i];</span><br><span class="line">        <span class="keyword">for</span> (i = 0; i &lt; len; <span class="keyword">sum</span>+=nums[i++]) </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">sum</span> *2 == <span class="keyword">total</span> - nums[i]) &#123;</span><br><span class="line">                <span class="keyword">ret</span> = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ret</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array of integers nums, write a method that returns the “pivot” index of this array.&lt;/p&gt;
&lt;p&gt;We define the pivot index as the ind
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode728. Self Dividing Numbers</title>
    <link href="http://mingyi.js.org/2017/11/24/LeetCode728-Self-Dividing-Numbers/"/>
    <id>http://mingyi.js.org/2017/11/24/LeetCode728-Self-Dividing-Numbers/</id>
    <published>2017-11-24T00:12:22.000Z</published>
    <updated>2017-12-04T13:06:04.243Z</updated>
    
    <content type="html"><![CDATA[<p>A self-dividing number is a number that is divisible by every digit it contains.</p><p>For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.</p><p>Also, a self-dividing number is not allowed to contain the digit zero.</p><p>Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"><span class="section">Input: </span></span><br><span class="line">left = 1, right = 22</span><br><span class="line"><span class="section">Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span></span><br></pre></td></tr></table></figure><p>Note:<br>The boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000.</p><p>依次对范围内的每个数做判断，比较简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSelfDivid</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = num, t2;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (t1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            t2 = t1 % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (t2 == <span class="number">0</span>) &#123;</span><br><span class="line">                ret = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num % t2 != <span class="number">0</span>) &#123;</span><br><span class="line">                ret = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t1 = t1 / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selfDividingNumbers(<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (; left &lt;= right; left ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSelfDivid(left)) &#123;</span><br><span class="line">                ret.push_back(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A self-dividing number is a number that is divisible by every digit it contains.&lt;/p&gt;
&lt;p&gt;For example, 128 is a self-dividing number becaus
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库存储系统漫谈</title>
    <link href="http://mingyi.js.org/2017/10/23/Discussion-on-database-system/"/>
    <id>http://mingyi.js.org/2017/10/23/Discussion-on-database-system/</id>
    <published>2017-10-23T17:32:03.000Z</published>
    <updated>2017-12-04T13:06:04.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="从大作业说起"><a href="#从大作业说起" class="headerlink" title="从大作业说起"></a>从大作业说起</h4><p>上大学的时候，相信很多学软件工程的同学常会有个大作业要求做一个图书管理系统或人事管理系统，本质上就是设计一个数据库存储系统。我们以图书管理系统为例，假设需要存储的字段有id,name(书名),author(作者)，查询的需求为根据id去获取图书的信息。</p><p>最简单的做法，以id为key，剩下的作为value，在内存中构建一个hashtable，或者R/B tree 比如c++ stl里的map，全内存存储，这是在数据量不大的情况下。内存的随机读写的性能是非常好的，1s中大约能查询1千万次。</p><p>接下来考虑数据量增大的情况，当数据已经在内存中存不下了，那就得靠存磁盘了，通常的考虑是每条记录按顺序存下来，放到一个文件里去，内存中仍然有一个hashtable，以id为key，value为对应数据记录在文件中的offset(偏移量)。这种做法的特点是数据本身是序列化存在磁盘上的，但索引是存内存中的，当要查询的时候，首先在内存中根据id找到对应磁盘文件的offset，再在文件中fseek定位并读出数据</p><p>现在我们来分析下目前这个存储系统的性能是怎样的，通常对一个存储系统来说，性能评价指标是IOPS(每秒做多少次IO)，以SATA磁盘为例，它的寻道时间平均是在10ms，我们每次查询一条数据，需要一次磁盘的寻道操作，也就是说如果忽略掉磁盘的缓存及本身电梯算法带来的优化，1s中只能做100次这样的查询</p><p>再进一步考虑，假设数据量大到索引也不能够全内存了该怎么处理？这里假设id是有序的，就可以考虑用B+ tree来存，B+ tree有三种节点，根节点、非叶子节点、叶子节点，根据B+ tree的特点，非叶子节点的数量一定是比叶子节点的数量少的多，这些节点信息全部是存在磁盘上的，而在实际应用中非叶子节点是会被大量缓存住的，故在分析性能时可以将非叶子节点当做是存储在内存中来分析。</p><p><img src="http://mingyi-1251130916.file.myqcloud.com/blog/B%2BTREE.jpeg" alt=""></p><p>在这种情况下，单个查询是如何进行的呢？从根节点开始, 一层层的找到叶子节点中的数据。非叶子节点的索引信息假设都从内存缓存中读取，相对于磁盘IO来讲，时间可以忽略不计。读取叶子节点的索引值有1次fseek，同时读取数据内容还需要1次fseek。也就是说每次查询要有2次磁盘寻道，qps下降到50；<br>假设有一个范围查询的需求，需要查询id从50 - 100范围的记录。 50个id，要fseek100次。也就是说这个查询要1s才能返回，而且这个时间是完全落在磁盘的随机IO上，很难从硬件或提高并发来做优化，性能是非常糟糕的。在这里很重要的一个思想，是要想办法把所有的随机读随机写都转成顺序读和顺序写。磁盘本身的顺序读写是非常好的，像SATA磁盘每秒可以写50M。那可以考虑数据按照page组织起来，让数据在page之间按id是有序的，这种情况下，我只需要fseek找50所在的偏移量，接下来顺序的读一批，10ms读索引，10ms读50所在的page的数据。读都是以page为单位的。<br>这里如果是全局有序的，而不按page会有什么问题？如果严格有序就会很惨，每次插入新的元素，都会有节点的分裂，会有更多的IO操作。按page的话，page可能没有写满，剩下的一些空间就是用来插这个范围之内的可能写入的其他id。这种方式可以提高一些插入的性能。</p><p>作为一个软件工程的作业，做到这里已经算是非常非常优秀的成果了。对于存储系统而言，接下来还要考虑是怎么访问的，也就是函数API或者叫存储系统的界面。数据库系统提供的访问界面是SQL，事实上我们也可以不通过SQL来访问，比如innodb，能把mysql上面一层去掉，通过HandlerSocket插件提供的API接口，进而不通过SQL去访问它。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>数据库的主要功能是保证ACID。我们前面的访问都只是单个的访问，那么假设我们有两个线程在同时读写，那如何让这两个线程看起来像是独占这个存储系统一样，这就是数据库的隔离性(I)。I是通过锁来保证的，一个操作会锁住的内容比想象的要多得多。A是原子性。数据库保证我们的数据安全，要么是没有做的状态，要么是完成的状态，不应该有中间的状态，即使掉电。C是一致性，系统从一个一致的状态转换到另一个一致的状态，分为强一致性、弱一致性和最终一致性，在分布式存储系统受通信延迟，系统负载等影响，要实现不同的一致性会有不同的挑战，根据具体的业务会做一些取舍；D持久性，数据要持久化存储，同时还要有日志。</p><p>KV的一些NoSQL存储系统，实际上是放宽了ACID的条件约束，来实现更高的性能，比如不支持事务的并发，只支持单条的事务，还有比如一致性，写下去不一定成功，只有当merge的时候才能成功。一般说数据库性能差，主要是因为数据库为了实现ACID、transaction等功能牺牲了性能。</p><h4 id="拿mysql来看数据库系统有哪些模块"><a href="#拿mysql来看数据库系统有哪些模块" class="headerlink" title="拿mysql来看数据库系统有哪些模块"></a>拿mysql来看数据库系统有哪些模块</h4><p><img src="http://mingyi-1251130916.file.myqcloud.com/blog/mysql-engine-overview.png" alt=""></p><p>比较重要的几个模块：</p><ol><li>数据库客户端，通常来说会做成一个lib，应用端可以通过这个lib来与数据库交互</li><li>连接池，验证/线程重用/最大连接数限制</li><li>SQL解析器，SQL parser</li><li>优化器，根据解析后的SQL的一些条件，决定走哪一个执行路径。使用哪个索引得到需要的数据。同一条SQL语句在不同的执行路径下千差万别，数据库最最重要和复杂的就是优化器，像商业数据库相比开源数据库最大的优势就是优化器会做的更专业，也会存在非常多的专利</li><li>缓存，因为磁盘的随机IO惨不忍睹，所以通常要把查询的结果缓存起来<br>对于缓存来讲，这次读完下次不再需要了的，是完全没必要缓存。而像数据库系统的一个特点是现在要读的通常是刚读过不久的，也就是所谓的时效性的一个热点，这种情况下读缓存和写缓存会起到非常大的作用。缓存利用的好的话，所有查询都落到内存中，qps可能好几千上万，如果不幸的话全部落在磁盘上的话，qps也就只有一两百了。<br>MySQL 5.1以后是插件式的一个系统，数据是怎么结构化存储的、索引是怎么组织的、以及加锁等都是通过接口的方式提供出来，方便做二次开发。只要实现<a href="https://github.com/mysql/mysql-server/blob/5.7/sql/handler.h" target="_blank" rel="noopener">handler.h</a>里的这些接口，就可以做一个MySQL的存储引擎，没有想象的那么复杂。MySQL也自带innodb、myISAM等存储引擎，悲剧在于没有一个存储引擎特别好用。</li><li>存储引擎下面是跟文件系统打交道。数据、索引、日志</li></ol><h4 id="数据库本身是如何做结构化存储"><a href="#数据库本身是如何做结构化存储" class="headerlink" title="数据库本身是如何做结构化存储"></a>数据库本身是如何做结构化存储</h4><ol><li><p>单条记录的结构<br>对于一条数据记录，有些字段可以为空，有些有default值，有些是可以变长的。通常来讲会在记录头记录一个总长度，后面是一些pointer，比如有指向后面哪些字段是可以为空并且为空的等等，之后是根据表结构的定义，一个字段一个字段挨着存储。</p></li><li><p>页的结构<br>将每个记录的指针按插入的顺序串起来，作为page里的数据。注意这些数据并不是按key有序的而是按插入顺序。<br>假设在往page里写一半的时候掉电了，重启之后，怎么判断这个page是好的还是坏的？通常的做法是在page的首尾各加2byte放一个cookie，要么为10或者01，好的page首尾的cookie是一致的，在开始写的时候，头部如果是10就改为01，在写完的时候把尾部的10也改为01。就是说如果读上来一个page，头部是10，尾部是01，那这个page的数据就是坏的。<br>那page如果坏掉了，就要从日志里恢复，所以page里一定还要记一个跟日志相关联的信息叫LSN。<br>日志里要存的信息有 UNDO(做之前)/REDO(做之后)，以及这个操作是在哪个page，还有LSN。单机的话可以拿相对于日志文件头的偏移量作为LSN，也可以用时间戳，集群的话就需要一个中央的授时。<br>在重启后，读出最后一个page的LSN，并找到对应的日志，通过之后的日志可以知道丢了多少条更新可以进行重做，或者事务的回滚</p></li><li><p>表和索引的结构<br>索引是用B+ tree的结构，节点里一般存上page id + record id<br>innodb的实现是区分主键索引和辅助索引。对于主键索引数据本身作为索引的leaf page。这样做按主键做范围查询，性能是非常好的。而对于辅助索引里存放的是主键索引所在的节点地址。<br>如果查询是命中的辅助索引，就会先找到这个辅助索引的leaf page再走一遍主键索引。所以innodb命中主键索引和辅助索引即使是单条查询性能也是不一样的。</p></li></ol><h4 id="数据库的四种访问模式，怎么从数据库里找到一条数据"><a href="#数据库的四种访问模式，怎么从数据库里找到一条数据" class="headerlink" title="数据库的四种访问模式，怎么从数据库里找到一条数据"></a>数据库的四种访问模式，怎么从数据库里找到一条数据</h4><ol><li><p>Table Scan<br>在没有where的时候，或者where条件没有命中任何索引，优化器就什么都不能做了，只能全表扫描。对于大表来说，一个SQL全表扫描跑个几天都是常见的。</p></li><li><p>Index Only<br>有个联合索引 id, name。查询为select name from table where id = xx 在这种情况下，只需要读到这个索引，就可以直接返回了，这是最好的一种情况。</p></li><li><p>Index Match<br>最常见到的，通过id命中index，通过index打开数据文件，将数据内容读取出来返回。</p></li><li><p>Index Scan<br>假设有一个id和name的联合索引，查询是select id from table where name &gt;xxx，这个索引是用不了的。这种时候数据库优化器会发现只要Index Scan就能满足查询要求，故不用Table Scan。</p></li></ol><h4 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h4><p>聚集索引是指数据是按照索引排序的，对于Innodb毫无疑问主键索引就是聚集索引。为什么要按照索引对数据排序，这个主要是在范围查询的时候，按照主键顺序查询的时候性能是很好的。</p><h4 id="总结一下使用数据库系统影响性能的关键"><a href="#总结一下使用数据库系统影响性能的关键" class="headerlink" title="总结一下使用数据库系统影响性能的关键"></a>总结一下使用数据库系统影响性能的关键</h4><p>索引的设计，索引设计的好，直接会是Index Only或者Index Match的，设计的不好就得是Table Scan全表扫描了<br>聚集非聚集索引，对于范围查询是至关重要的<br>数据库SQL性能优化思路</p><ol><li>尽量走索引</li><li>避免随机IO，不多解释了</li><li>Innodb的Insert buffer对写性能的优化<br>随机写主键索引可能需要1到2次IO，辅助索引也可能是1到2次IO，这么多次随机IO导致写入性能是非常低下的。在这里假设所有索引不需要保证唯一性，顺序将数据先写入Insert buffer page，在空闲的时候再把Insert buffer里的数据merge写到最终需要的地方，慢慢去做随机IO。这种在写入高峰期的时候能起到明显的性能提升。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;从大作业说起&quot;&gt;&lt;a href=&quot;#从大作业说起&quot; class=&quot;headerlink&quot; title=&quot;从大作业说起&quot;&gt;&lt;/a&gt;从大作业说起&lt;/h4&gt;&lt;p&gt;上大学的时候，相信很多学软件工程的同学常会有个大作业要求做一个图书管理系统或人事管理系统，本质上就是设计一个
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="存储系统" scheme="http://mingyi.js.org/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
