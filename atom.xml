<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茗一的笔记</title>
  
  <subtitle>沉淀</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mingyi.js.org/"/>
  <updated>2017-12-06T14:10:34.941Z</updated>
  <id>http://mingyi.js.org/</id>
  
  <author>
    <name>Mingyi Liang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode240. Search a 2D Matrix II</title>
    <link href="http://mingyi.js.org/2017/12/06/LeetCode240-Search-a-2D-Matrix-II/"/>
    <id>http://mingyi.js.org/2017/12/06/LeetCode240-Search-a-2D-Matrix-II/</id>
    <published>2017-12-06T17:37:46.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">问题来自LeetCode240</a></p><p>比较取巧的一个方法是选择右上角的元素matrix[i][j]和target作比较，如果比target大，则一定不在最后一列，如果比target下，则一定不在第一行，如果相等，则找到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size(), i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种方法是用分治的思想，选取中心点元素，如果正好与target相等，则找到了，如果比target小，则target一定不在第一象限的子矩阵里，如果比target大，则target一定不在第四象限的子矩阵里。排除第一或第四象限的子矩阵后，还剩一个原来1/4的矩阵和一个1/2的子矩阵，分别再在子矩阵中递归该过程，直到找到结果</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    bool find(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 &gt; x2 || y1 &gt; y2)</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> midx = (x1 + x2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midy = (y1 + y2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">matrix</span>[midx][midy])</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">matrix</span>[midx][midy] &gt; target ? (find(<span class="keyword">matrix</span>, x1, y1, x2, midy - <span class="number">1</span>, target) || find(<span class="keyword">matrix</span>, x1, midy, midx - <span class="number">1</span>, y2, target)) : (find(<span class="keyword">matrix</span>, midx + <span class="number">1</span>, y1, x2, midy, target) || find(<span class="keyword">matrix</span>, x1, midy + <span class="number">1</span>, x2, y2, target));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool searchMatrix(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="keyword">matrix</span>.<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">return</span> find(<span class="keyword">matrix</span>, <span class="number">0</span>, <span class="number">0</span>, m - <span class="number">1</span>, n - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/search-a-2d-matrix-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;问题来自LeetCode240&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比较取巧的一个方法是选择右上角的
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode300. Longest Increasing Subsequence</title>
    <link href="http://mingyi.js.org/2017/12/05/LeetCode300-Longest-Increasing-Subsequence/"/>
    <id>http://mingyi.js.org/2017/12/05/LeetCode300-Longest-Increasing-Subsequence/</id>
    <published>2017-12-05T23:49:36.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">问题来自LeetCode300</a></p><p>dp[i]表示以第i位结尾的长度，则状态转移方程dp[i] = max(d[j] + 1) &amp;&amp; i &gt; j &amp;&amp; nums[i] &gt; nums[j]<br>初值 dp[i] = 1，时间复杂度O(n2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size(), ret = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len, <span class="number">1</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-increasing-subsequence&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;问题来自LeetCode300&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dp[i]表示以
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode72. Edit Distance</title>
    <link href="http://mingyi.js.org/2017/12/04/LeetCode72-Edit-Distance/"/>
    <id>http://mingyi.js.org/2017/12/04/LeetCode72-Edit-Distance/</id>
    <published>2017-12-04T21:00:56.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p><p>You have the following 3 operations permitted on a word:</p><p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p><p>最短编辑距离，比较经典的DP求解问题</p><p>状态转移方程<br>dp[i][j] = min(dp[i - 1][j - 1] + same(word1[i - 1], word2[j - 1]), dp[i - 1][j] + 1, dp[i][j - 1] + 1)</p><p>初值<br>dp[0][j] = j<br>dp[i][0] = i</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>), </span><br><span class="line">                                   min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                                  );   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 ste
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode740. Delete and Earn</title>
    <link href="http://mingyi.js.org/2017/12/04/LeetCode740-Delete-and-Earn/"/>
    <id>http://mingyi.js.org/2017/12/04/LeetCode740-Delete-and-Earn/</id>
    <published>2017-12-04T11:20:32.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array nums of integers, you can perform operations on the array.</p><p>In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.</p><p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><p>Example 1:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3, 4, 2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line"><span class="keyword">Delete</span> <span class="number">4</span> <span class="keyword">to</span> earn <span class="number">4</span> points, consequently <span class="number">3</span> <span class="keyword">is</span> also deleted.</span><br><span class="line"><span class="keyword">Then</span>, <span class="keyword">delete</span> <span class="number">2</span> <span class="keyword">to</span> earn <span class="number">2</span> points. <span class="number">6</span> total points <span class="keyword">are</span> earned.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">Output: <span class="number">9</span></span><br><span class="line">Explanation: </span><br><span class="line">Delete <span class="number">3</span> to earn <span class="number">3</span> <span class="built_in">points</span>, deleting both <span class="number">2</span>'s <span class="keyword">and</span> the <span class="number">4</span>.</span><br><span class="line">Then, <span class="built_in">delete</span> <span class="number">3</span> again to earn <span class="number">3</span> <span class="built_in">points</span>, <span class="keyword">and</span> <span class="number">3</span> again to earn <span class="number">3</span> <span class="built_in">points</span>.</span><br><span class="line"><span class="number">9</span> total <span class="built_in">points</span> are earned.</span><br></pre></td></tr></table></figure><p>Note:</p><p>The length of nums is at most 20000.<br>Each element nums[i] is an integer in the range [1, 10000].</p><p>动态规划问题，状态转移方程<br>dp[i] = max(dp[i - 1], dp[i - 2] + a[i])</p><p>初值<br>dp[1] = a[1]<br>dp[2] = max(dp[1], a[2] * 2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10001</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) </span><br><span class="line">            a[i]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">10001</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = max(dp[<span class="number">1</span>], a[<span class="number">2</span>] * <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + a[i] * i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">10000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array nums of integers, you can perform operations on the array.&lt;/p&gt;
&lt;p&gt;In each operation, you pick any nums[i] and delete it to
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode738. Monotone Increasing Digits</title>
    <link href="http://mingyi.js.org/2017/12/03/LeetCode738-Monotone-Increasing-Digits/"/>
    <id>http://mingyi.js.org/2017/12/03/LeetCode738-Monotone-Increasing-Digits/</id>
    <published>2017-12-03T18:52:14.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.</p><p>(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x &lt;= y.)</p><p>Example 1:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> N = <span class="number">10</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> N = <span class="number">1234</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> N = <span class="number">332</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">299</span></span><br></pre></td></tr></table></figure><p>Note: N is an integer in the range [0, 10^9].</p><p>比较笨的办法，从N开始，一个一个的判断，直到找到符合要求的数。但其中有很多判断是多余的，可以做一些优化，减少判断的次数。比如当检测332不符合要求，则331、330都是没必要去判断的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkNum</span><span class="params">(<span class="keyword">int</span> &amp;N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = N, t1 = <span class="number">9</span>, t2, offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t) &#123;</span><br><span class="line">            t2 = t % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (t1 &lt; t2) &#123;</span><br><span class="line">                N = t * <span class="built_in">pow</span>(<span class="number">10</span>, offset);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t = t / <span class="number">10</span>;</span><br><span class="line">            offset ++;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = N;</span><br><span class="line">        <span class="keyword">while</span> (ret-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkNum(ret))</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.&lt;/p&gt;
&lt;p&gt;(Recall t
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode739. Daily Temperatures</title>
    <link href="http://mingyi.js.org/2017/12/03/LeetCode739-Daily-Temperatures/"/>
    <id>http://mingyi.js.org/2017/12/03/LeetCode739-Daily-Temperatures/</id>
    <published>2017-12-03T18:46:42.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.</p><p>For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].</p><p>Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].</p><p>比较简单，利用栈来做，如果后一个数比前一个数小，则入栈，否则出栈。入栈的同时顺带计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret(len);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; temperatures[i] &gt; temperatures[s.top()]) &#123;</span><br><span class="line">                tmp = ret[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!s.empty()) </span><br><span class="line">                    ret[s.top()] += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            s.push(i);</span><br><span class="line">            ret[s.top()] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            ret[s.top()] = <span class="number">0</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode64. Minimum Path Sum</title>
    <link href="http://mingyi.js.org/2017/12/02/LeetCode64-Minimum-Path-Sum/"/>
    <id>http://mingyi.js.org/2017/12/02/LeetCode64-Minimum-Path-Sum/</id>
    <published>2017-12-02T18:55:20.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p><p>Note: You can only move either down or right at any point in time.</p><p>Example 1:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.</p><p>动态规划问题，先确定状态转移方程，dp[i][j]表示到下标为i,j的位置时的最优解</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">j</span>] = min(dp[<span class="string">i</span>][<span class="symbol">j - 1</span>], dp[<span class="string">i - 1</span>][<span class="symbol">j</span>]) + grid[<span class="string">i</span>][<span class="symbol">j</span>]</span><br></pre></td></tr></table></figure><p>初值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">0</span>][<span class="symbol">0</span>] = grid[<span class="string">0</span>][<span class="symbol">0</span>]</span><br><span class="line">dp[<span class="string">0</span>][<span class="symbol">j &gt; 0</span>] = dp[<span class="string">0</span>][<span class="symbol">j - 1</span>] + grid[<span class="string">i</span>][<span class="symbol">j</span>] // 第一行只能横着走</span><br><span class="line">dp[<span class="string">i &gt; 0</span>][<span class="symbol">0</span>] = dp[<span class="string">i - 1</span>][<span class="symbol">0</span>] + grid[<span class="string">i</span>][<span class="symbol">j</span>] // 最左列只能竖着走</span><br></pre></td></tr></table></figure><p>时间复杂度O(mn)，空间复杂度O(mn)，可以通过滚动数组优化把空间复杂度降维到O(n)</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">int</span> minPathSum(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="keyword">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="keyword">grid</span>.<span class="keyword">size</span>(), n = <span class="keyword">grid</span>[<span class="number">0</span>].<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">grid</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="keyword">grid</span>[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="keyword">grid</span>[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="keyword">grid</span>[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers alo
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode108. Convert Sorted Array to Binary Search Tree</title>
    <link href="http://mingyi.js.org/2017/12/02/LeetCode108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
    <id>http://mingyi.js.org/2017/12/02/LeetCode108-Convert-Sorted-Array-to-Binary-Search-Tree/</id>
    <published>2017-12-02T17:25:09.000Z</published>
    <updated>2017-12-06T14:10:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted array: [<span class="string">-10</span>,<span class="string">-3</span>,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,<span class="string">-3</span>,9,<span class="string">-10</span>,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   <span class="string">-3</span>   9</span><br><span class="line">   /   /</span><br><span class="line"> <span class="string">-10</span>  5</span><br></pre></td></tr></table></figure><p>数组转BST，比链表要简单</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">typedef vector&lt;<span class="built_in">int</span>&gt;::iterator vec_iter;</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* &amp;root, vec_iter first, vec_iter last) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = last - first;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">0</span>)</span><br><span class="line">            return ;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">len</span> - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(*(first + <span class="built_in">mid</span>));</span><br><span class="line">        </span><br><span class="line">        TreeNode *myleft = nullptr, *myright = nullptr;</span><br><span class="line">        helper(myleft, first, first + <span class="built_in">mid</span>);</span><br><span class="line">        helper(myright, first + <span class="built_in">mid</span> + <span class="number">1</span>, last);</span><br><span class="line">        root-&gt;<span class="built_in">left</span> = myleft;</span><br><span class="line">        root-&gt;<span class="built_in">right</span> = myright;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        TreeNode* root = nullptr;</span><br><span class="line">        helper(root, nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;p&gt;For this problem, a height-balan
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode109. Convert Sorted List to Binary Search Tree</title>
    <link href="http://mingyi.js.org/2017/12/01/LeetCode109-Convert-Sorted-List-to-Binary-Search-Tree/"/>
    <id>http://mingyi.js.org/2017/12/01/LeetCode109-Convert-Sorted-List-to-Binary-Search-Tree/</id>
    <published>2017-12-01T18:14:54.000Z</published>
    <updated>2017-12-06T14:10:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted linked list: [<span class="string">-10</span>,<span class="string">-3</span>,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,<span class="string">-3</span>,9,<span class="string">-10</span>,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   <span class="string">-3</span>   9</span><br><span class="line">   /   /</span><br><span class="line"> <span class="string">-10</span>  5</span><br></pre></td></tr></table></figure><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     ListNode *<span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(<span class="built_in">int</span> x) : val(x), <span class="keyword">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> getLen(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            head = head-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="built_in">len</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="built_in">len</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(ListNode* head, <span class="built_in">int</span> <span class="built_in">len</span>, TreeNode* &amp;root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            root = nullptr;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* <span class="built_in">now</span> = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = (<span class="built_in">len</span> - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">now</span> = <span class="built_in">now</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(<span class="built_in">now</span>-&gt;val);</span><br><span class="line">        TreeNode *<span class="built_in">left</span>, *<span class="built_in">right</span>;</span><br><span class="line">        helper(head, (<span class="built_in">len</span> - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, <span class="built_in">left</span>);</span><br><span class="line">        helper(<span class="built_in">now</span>-&gt;<span class="keyword">next</span>, <span class="built_in">len</span> &gt;&gt; <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">        root-&gt;<span class="built_in">left</span> = <span class="built_in">left</span>;</span><br><span class="line">        root-&gt;<span class="built_in">right</span> = <span class="built_in">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        TreeNode* root;</span><br><span class="line">        helper(head, getLen(head), root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;p&gt;For this problem, a 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode114. Flatten Binary Tree to Linked List</title>
    <link href="http://mingyi.js.org/2017/12/01/LeetCode114-Flatten-Binary-Tree-to-Linked-List/"/>
    <id>http://mingyi.js.org/2017/12/01/LeetCode114-Flatten-Binary-Tree-to-Linked-List/</id>
    <published>2017-12-01T16:16:51.000Z</published>
    <updated>2017-12-06T14:10:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example,<br>Given</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><p>The flattened tree should look like:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure><p>二叉树转链表</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* &amp;root, TreeNode* &amp;last) &#123;</span><br><span class="line">        last = root;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        TreeNode *mylast, *temp = root-&gt;<span class="built_in">right</span>;</span><br><span class="line">        helper(root-&gt;<span class="built_in">left</span>, mylast);</span><br><span class="line">        <span class="keyword">if</span> (mylast) &#123;</span><br><span class="line">            last = mylast;</span><br><span class="line">            last-&gt;<span class="built_in">right</span> = root-&gt;<span class="built_in">right</span>;</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = root-&gt;<span class="built_in">left</span>;</span><br><span class="line">            root-&gt;<span class="built_in">left</span> = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(root-&gt;<span class="built_in">right</span>, mylast);</span><br><span class="line">        <span class="keyword">if</span> (mylast)</span><br><span class="line">            last = mylast;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *last;</span><br><span class="line">        helper(root, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a binary tree, flatten it to a linked list in-place.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given&lt;/p&gt;
&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode98. Validate Binary Search Tree</title>
    <link href="http://mingyi.js.org/2017/11/30/LeetCode98-Validate-Binary-Search-Tree/"/>
    <id>http://mingyi.js.org/2017/11/30/LeetCode98-Validate-Binary-Search-Tree/</id>
    <published>2017-11-30T18:17:26.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Binary tree <code>[2,1,3]</code>, return true.<br>Example 2:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Binary tree <code>[1,2,3]</code>, return false.</p><p>将BST的中序遍历的结果存起来然后判断是否有序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode* root, <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        travel(root-&gt;left, s);</span><br><span class="line">        s.push(root-&gt;val);</span><br><span class="line">        travel(root-&gt;right, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        travel(root, s);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.top() &gt;= last)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            last = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a binary tree, determine if it is a valid binary search tree (BST).&lt;/p&gt;
&lt;p&gt;Assume a BST is defined as follows:&lt;/p&gt;
&lt;p&gt;The left subt
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode111. Minimum Depth of Binary Tree</title>
    <link href="http://mingyi.js.org/2017/11/30/LeetCode111-Minimum-Depth-of-Binary-Tree/"/>
    <id>http://mingyi.js.org/2017/11/30/LeetCode111-Minimum-Depth-of-Binary-Tree/</id>
    <published>2017-11-30T16:31:48.000Z</published>
    <updated>2017-12-06T14:10:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        int ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;<span class="built_in">left</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;<span class="built_in">right</span>) &#123;</span><br><span class="line">                ret = min(minDepth(root-&gt;<span class="built_in">left</span>), minDepth(root-&gt;<span class="built_in">right</span>)) + <span class="number">1</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret = minDepth(root-&gt;<span class="built_in">left</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;<span class="built_in">right</span>) &#123;</span><br><span class="line">            ret = minDepth(root-&gt;<span class="built_in">right</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a binary tree, find its minimum depth.&lt;/p&gt;
&lt;p&gt;The minimum depth is the number of nodes along the shortest path from the root node d
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode106. Construct Binary Tree from Inorder and Postorder Traversal</title>
    <link href="http://mingyi.js.org/2017/11/29/LeetCode106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/"/>
    <id>http://mingyi.js.org/2017/11/29/LeetCode106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</id>
    <published>2017-11-29T17:33:26.000Z</published>
    <updated>2017-12-06T14:10:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>已知树的中序和后序遍历，构建这棵树，跟105思路一样，比较简单</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* helper(vector&lt;<span class="built_in">int</span>&gt;&amp; inorder, vector&lt;<span class="built_in">int</span>&gt;&amp; postorder, <span class="built_in">int</span> inpos, <span class="built_in">int</span> postpos, <span class="built_in">int</span> <span class="built_in">len</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">0</span>)</span><br><span class="line">            return nullptr;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(postorder[postpos + <span class="built_in">len</span> <span class="number">-1</span>]);</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; inorder[i + inpos] != postorder[postpos + <span class="built_in">len</span> <span class="number">-1</span>]; i++) ;</span><br><span class="line">        root-&gt;<span class="built_in">left</span> = helper(inorder, postorder, inpos, postpos, i);</span><br><span class="line">        root-&gt;<span class="built_in">right</span> = helper(inorder, postorder, inpos + i + <span class="number">1</span>, postpos + i, <span class="built_in">len</span> - i - <span class="number">1</span>);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;<span class="built_in">int</span>&gt;&amp; inorder, vector&lt;<span class="built_in">int</span>&gt;&amp; postorder) &#123;</span><br><span class="line">        return helper(inorder, postorder, <span class="number">0</span>, <span class="number">0</span>, postorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given inorder and postorder traversal of a tree, construct the binary tree.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that duplicates do not exist i
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link href="http://mingyi.js.org/2017/11/29/LeetCode105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
    <id>http://mingyi.js.org/2017/11/29/LeetCode105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</id>
    <published>2017-11-29T17:15:20.000Z</published>
    <updated>2017-12-06T14:10:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>已知树的先序和中序遍历，构建这棵树。比较简单</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    TreeNode* helper(vector&lt;<span class="built_in">int</span>&gt;&amp; preorder, vector&lt;<span class="built_in">int</span>&gt;&amp; inorder, <span class="built_in">int</span> prepos, <span class="built_in">int</span> inpos, <span class="built_in">int</span> <span class="built_in">len</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span> == <span class="number">0</span>)</span><br><span class="line">            return nullptr;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[prepos]);</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; inorder[i + inpos] != preorder[prepos]; i++) ;</span><br><span class="line">        root-&gt;<span class="built_in">left</span> = helper(preorder, inorder, prepos + <span class="number">1</span>, inpos, i);</span><br><span class="line">        root-&gt;<span class="built_in">right</span> = helper(preorder, inorder, prepos + i + <span class="number">1</span>, inpos + i + <span class="number">1</span>, <span class="built_in">len</span> - i - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* buildTree(vector&lt;<span class="built_in">int</span>&gt;&amp; preorder, vector&lt;<span class="built_in">int</span>&gt;&amp; inorder) &#123;</span><br><span class="line">        return helper(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, inorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given preorder and inorder traversal of a tree, construct the binary tree.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that duplicates do not exist in
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode84. Largest Rectangle in Histogram</title>
    <link href="http://mingyi.js.org/2017/11/28/LeetCode84-Largest-Rectangle-in-Histogram/"/>
    <id>http://mingyi.js.org/2017/11/28/LeetCode84-Largest-Rectangle-in-Histogram/</id>
    <published>2017-11-28T13:53:54.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt=""></p><p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt=""></p><p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><p>For example,<br>Given heights = <code>[2,1,5,6,2,3]</code>,<br>return 10.</p><p>栈顶元素比新元素小时，入栈，确定左边界，当栈顶元素比新元素大时，出栈，确定右边界，并计算此时的面积，顺带比较最大值。时间复杂度O(n)</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    int largestRectangleArea(<span class="title">vector</span>&lt;<span class="title">int</span>&gt;&amp; <span class="title">heights</span>) &#123;</span></span><br><span class="line"><span class="class">        int n = heights.size(), result = 0, h;</span></span><br><span class="line"><span class="class">        stack&lt;int&gt; s;</span></span><br><span class="line"><span class="class">        for (<span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">n</span>; <span class="title">i</span>++) &#123;</span></span><br><span class="line"><span class="class">            while(!<span class="title">s</span>.<span class="title">empty</span>() &amp;&amp; heights[s.top()] &gt; heights[i]) &#123;</span></span><br><span class="line"><span class="class">                h = heights[s.top()];</span></span><br><span class="line"><span class="class">                s.pop();</span></span><br><span class="line"><span class="class">                result = max(<span class="title">result</span>, (<span class="title">i</span> - 1 - (<span class="title">s</span>.<span class="title">empty</span>()?(-1):s.top())) * h);</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">            s.push(<span class="title">i</span>);</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        while(!<span class="title">s</span>.<span class="title">empty</span>()) &#123;</span></span><br><span class="line"><span class="class">            h = heights[s.top()];</span></span><br><span class="line"><span class="class">            s.pop();</span></span><br><span class="line"><span class="class">            result = max(<span class="title">result</span>, (<span class="title">n</span> - 1 - (<span class="title">s</span>.<span class="title">empty</span>()?(-1):s.top())) * h);</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        return result;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode92. Reverse Linked List II</title>
    <link href="http://mingyi.js.org/2017/11/27/LeetCode92-Reverse-Linked-List-II/"/>
    <id>http://mingyi.js.org/2017/11/27/LeetCode92-Reverse-Linked-List-II/</id>
    <published>2017-11-27T20:42:06.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p><p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, m = 2 and n = 4,</p><p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p><p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p><p>链表的操作，不难，就是比较繁琐，在纸上先画出操作步骤理清思路。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="symbol">class</span> Solution &#123;</span><br><span class="line"><span class="symbol">public</span>:</span><br><span class="line">    ListNode* <span class="keyword">reverseLinklist(ListNode* </span>head) &#123;</span><br><span class="line">        ListNode *<span class="built_in">p1</span> = head, *<span class="built_in">p2</span> = head-&gt;next, *tmp<span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p2</span>) &#123;</span><br><span class="line">            tmp = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span>-&gt;next = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p2</span><span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span> = tmp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = nullptr<span class="comment">;</span></span><br><span class="line">        return <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* <span class="keyword">reverseBetween(ListNode* </span>head, int m, int n) &#123;</span><br><span class="line">        <span class="meta">if</span> (head == nullptr <span class="title">||</span> head-&gt;next == nullptr <span class="title">||</span> m == n)</span><br><span class="line">            return head<span class="comment">;</span></span><br><span class="line">        ListNode *<span class="built_in">p1</span> = head, *dummy = new ListNode(-<span class="number">1</span>), *<span class="built_in">p2</span> = dummy, *<span class="built_in">p3</span>, *<span class="built_in">p4</span>, *<span class="built_in">p5</span><span class="comment">;</span></span><br><span class="line">        dummy-&gt;next = head<span class="comment">;</span></span><br><span class="line">        int i = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p1</span>) &#123;</span><br><span class="line">            <span class="meta">if</span> (i == m &amp;&amp; <span class="built_in">p2</span>) &#123;</span><br><span class="line">                <span class="built_in">p2</span>-&gt;next = nullptr<span class="comment">;</span></span><br><span class="line">                <span class="built_in">p3</span> = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">            &#125; <span class="meta">else</span> <span class="meta">if</span> (i &lt; m) &#123;</span><br><span class="line">                <span class="built_in">p2</span> = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">if</span> (i == n) &#123;</span><br><span class="line">                <span class="built_in">p4</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">                <span class="built_in">p1</span>-&gt;next = nullptr<span class="comment">;</span></span><br><span class="line">                <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            i++<span class="comment">;     </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">p5</span> = <span class="keyword">reverseLinklist(p3);</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">p2</span>-&gt;next = <span class="built_in">p5</span><span class="comment">;</span></span><br><span class="line">        <span class="built_in">p3</span>-&gt;next = <span class="built_in">p4</span><span class="comment">;</span></span><br><span class="line">        return dummy-&gt;next<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reverse a linked list from position m to n. Do it in-place and in one-pass.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode142. Linked List Cycle II</title>
    <link href="http://mingyi.js.org/2017/11/27/LeetCode142-Linked-List-Cycle-II/"/>
    <id>http://mingyi.js.org/2017/11/27/LeetCode142-Linked-List-Cycle-II/</id>
    <published>2017-11-27T18:57:09.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>Note: Do not modify the linked list.</p><p>Follow up:<br>Can you solve it without using extra space?</p><p>笨办法就是把每个节点的地址塞入一个set里，每次set之前先find，第一次find到的那就是环的起始位置，这种方法需要额外的set容器。另一种做法仍然是用两根指针，p1每次走一步，p2每次走两步，当p1与p2相遇时，p1走过a步，p2走过b步。b = 2a; b - a = n <em> k; n 为p2在环内转的圈数，k为环的大小，则a = n </em> k；将p1放回起点，与p2再一起每次走一步，再次遇到的点即为换的起点。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="symbol">class</span> Solution &#123;</span><br><span class="line"><span class="symbol">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *<span class="built_in">p1</span> = head, *<span class="built_in">p2</span> = head, *ret<span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p1</span> &amp;&amp; <span class="built_in">p2</span>) &#123;</span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span> = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">if</span> (<span class="built_in">p2</span> == nullptr <span class="title">||</span> <span class="built_in">p2</span>-&gt;next == nullptr) &#123;</span><br><span class="line">                ret = nullptr<span class="comment">;</span></span><br><span class="line">                return ret<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">p2</span> = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="meta">if</span> (<span class="built_in">p1</span> == <span class="built_in">p2</span>) &#123;</span><br><span class="line">                <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">if</span> (<span class="built_in">p1</span> == head) &#123;</span><br><span class="line">            return <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">p1</span> = head<span class="comment">;</span></span><br><span class="line">        <span class="meta">while</span> (<span class="built_in">p1</span> &amp;&amp; <span class="built_in">p2</span>) &#123;</span><br><span class="line">            <span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            <span class="built_in">p2</span> = <span class="built_in">p2</span>-&gt;next<span class="comment">;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">if</span> (<span class="built_in">p1</span> == <span class="built_in">p2</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">                <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;/p&gt;
&lt;p&gt;Note: Do not modify the linked lis
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode138. Copy List with Random Pointer</title>
    <link href="http://mingyi.js.org/2017/11/27/LeetCode138-Copy-List-with-Random-Pointer/"/>
    <id>http://mingyi.js.org/2017/11/27/LeetCode138-Copy-List-with-Random-Pointer/</id>
    <published>2017-11-27T18:21:00.000Z</published>
    <updated>2017-12-06T14:10:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><p>带有一个random指针链表的拷贝。先在每个节点后面复制一个节点，然后再将复制的新节点的random指向新的节点。最后将新链表分离出来</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode *copyRandomList(RandomListNode *head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == nullptr)</span><br><span class="line">            return nullptr;</span><br><span class="line">            </span><br><span class="line">        RandomListNode *p = head, *tmp;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            R<span class="function"><span class="title">andomListNode</span> *n = new RandomListNode(p-&gt;</span>label); </span><br><span class="line">            <span class="function"><span class="title">tmp</span> = p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>next = n;</span><br><span class="line">            <span class="function"><span class="title">n</span>-&gt;</span>next = tmp;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = head;</span><br><span class="line">        <span class="function"><span class="title">while</span> (p &amp;&amp; p-&gt;</span>next) &#123;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">random</span> = p-&gt;</span><span class="function"><span class="title">random</span> == nullptr ? nullptr : p-&gt;</span><span class="function"><span class="title">random</span>-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = head;</span><br><span class="line">        R<span class="function"><span class="title">andomListNode</span> *h = p-&gt;</span>next, *t = h, *tail = p;</span><br><span class="line">        <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">            <span class="function"><span class="title">tail</span>-&gt;</span><span class="function"><span class="title">next</span> = t-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">if</span> (tail-&gt;</span>next == nullptr) &#123;</span><br><span class="line">                <span class="function"><span class="title">t</span>-&gt;</span>next = nullptr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">next</span> = tail-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">tail</span> = tail-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">t</span> = t-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode153. Find Minimum in Rotated Sorted Array</title>
    <link href="http://mingyi.js.org/2017/11/25/LeetCode153-Find-Minimum-in-Rotated-Sorted-Array/"/>
    <id>http://mingyi.js.org/2017/11/25/LeetCode153-Find-Minimum-in-Rotated-Sorted-Array/</id>
    <published>2017-11-25T17:43:45.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.</p><p>二分的思想</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size() - <span class="number">1</span>, <span class="built_in">mid</span>, ret;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">left</span> == <span class="built_in">right</span>)</span><br><span class="line">            return nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">left</span> &lt; <span class="built_in">right</span>) &#123;</span><br><span class="line">            <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">right</span> - <span class="built_in">left</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = min(nums[<span class="built_in">left</span>], nums[<span class="built_in">right</span>]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">left</span>] &lt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                ret = nums[<span class="built_in">left</span>];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">right</span> - <span class="built_in">left</span> == <span class="number">2</span> &amp;&amp; nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                ret = nums[<span class="built_in">right</span>];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">right</span> = <span class="built_in">mid</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., 0 1 2 4 5 6 7 might become 4
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode724. Find Pivot Index</title>
    <link href="http://mingyi.js.org/2017/11/24/LeetCode724-Find-Pivot-Index/"/>
    <id>http://mingyi.js.org/2017/11/24/LeetCode724-Find-Pivot-Index/</id>
    <published>2017-11-24T11:23:23.000Z</published>
    <updated>2017-12-06T14:10:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums, write a method that returns the “pivot” index of this array.</p><p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p><p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line">Input: </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: </span><br><span class="line">The <span class="built_in">sum</span> <span class="keyword">of</span> <span class="keyword">the</span> numbers <span class="built_in">to</span> <span class="keyword">the</span> left <span class="keyword">of</span> index <span class="number">3</span> (nums[<span class="number">3</span>] = <span class="number">6</span>) is equal <span class="built_in">to</span> <span class="keyword">the</span> <span class="built_in">sum</span> <span class="keyword">of</span> numbers <span class="built_in">to</span> <span class="keyword">the</span> <span class="literal">right</span> <span class="keyword">of</span> index <span class="number">3.</span></span><br><span class="line">Also, <span class="number">3</span> is <span class="keyword">the</span> <span class="keyword">first</span> index where this occurs.</span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">Input: </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">Output: <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>Explanation:<br>There is no index that satisfies the conditions in the problem statement.<br>Note:</p><ul><li>The length of nums will be in the range [0, 10000].</li><li>Each element nums[i] will be an integer in the range [-1000, 1000].</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int pivotIndex(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int <span class="keyword">ret</span> = -1, <span class="keyword">total</span> = 0, i, len = nums.size(), <span class="keyword">sum</span> = 0;</span><br><span class="line">        <span class="keyword">for</span> (i = 0; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">total</span> += nums[i];</span><br><span class="line">        <span class="keyword">for</span> (i = 0; i &lt; len; <span class="keyword">sum</span>+=nums[i++]) </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">sum</span> *2 == <span class="keyword">total</span> - nums[i]) &#123;</span><br><span class="line">                <span class="keyword">ret</span> = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ret</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array of integers nums, write a method that returns the “pivot” index of this array.&lt;/p&gt;
&lt;p&gt;We define the pivot index as the ind
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://mingyi.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://mingyi.js.org/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
